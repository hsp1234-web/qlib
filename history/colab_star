# -*- coding: utf-8 -*-
# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                                                                      â•‘
# â•‘   âœ¨ğŸº å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ (v50) ğŸº                                   âœ¨ğŸº â•‘
# â•‘                                                                      â•‘
# â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
# â•‘                                                                      â•‘
# â•‘ - V48 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **åŠŸèƒ½**: æ–°å¢æ—¥èªŒå¤šè¡Œé¡¯ç¤ºåŠŸèƒ½ï¼Œå„ªåŒ–è¡Œå‹•è£ç½®å¯è®€æ€§ã€‚             â•‘
# â•‘   - **ä¿®å¾©**: æ”¹ç”¨å‘½ä»¤åˆ—åƒæ•¸å‚³é FRED é‡‘é‘°ï¼Œå¾¹åº•è§£æ±ºæ³¨å…¥å¤±æ•—å•é¡Œã€‚   â•‘
# â•‘ - V47 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **ä¿®å¾©**: ä¿®æ­£ FRED é‡‘é‘°æœªè¢«æ³¨å…¥è³‡æ–™åº«å°è‡´å‰ç«¯ç„¡æ³•é¡¯ç¤ºçš„å•é¡Œã€‚   â•‘
# â•‘   - **ä¿®å¾©**: èª¿æ•´å•Ÿå‹•æ™‚åºï¼Œè§£æ±ºå› ç«¶çˆ­æ¢ä»¶å°è‡´çš„é¦–æ¬¡é‡‘é‘°è‡ªå‹•é©—è­‰å¤±æ•— â•‘
# â•‘     å•é¡Œã€‚                                                         â•‘
# â•‘   - **èª¿æ•´**: å°‡é è¨­åˆ†æ”¯æ›´æ–°è‡³ `91`ã€‚                                â•‘
# â•‘ - V46 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **é‡æ§‹**: èª¿æ•´å•Ÿå‹•æ™‚åºï¼Œä¿®å¾©å› ç«¶çˆ­æ¢ä»¶å°è‡´çš„é‡‘é‘°è¼‰å…¥èˆ‡é©—è­‰å¤±æ•—   â•‘
# â•‘     å•é¡Œï¼Œå¤§å¹…æå‡å•Ÿå‹•ç©©å®šæ€§ã€‚                                     â•‘
# â•‘ - V45 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **ä¿®å¾©**: ä¿®æ­£ `colabPro.py` åŸ·è¡Œç•°å¸¸å•é¡Œã€‚                      â•‘
# â•‘   - **èª¿æ•´**: æ›´æ–°é è¨­åˆ†æ”¯è™Ÿç¢¼ç‚º `90.1`ï¼Œä¸¦åŒæ­¥ç‰ˆæœ¬è™Ÿè‡³ `v45`ã€‚      â•‘
# â•‘ - V39 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **æˆ°ç•¥ä¿®æ­£**: æ¡ç”¨æœ€å°åŒ–ä¿®æ”¹ç­–ç•¥ï¼Œç‚º FRED é‡‘é‘°æ–°å¢å‰ç«¯ç‹€æ…‹æ¢æ¸¬   â•‘
# â•‘     æ¥å£ï¼Œä»¥ç¢ºä¿ç³»çµ±ç©©å®šæ€§ã€‚                                       â•‘
# â•‘ - V32 æ›´æ–°æ—¥èªŒ (2025-09-27):                                         â•‘
# â•‘   - **æ–°å¢åŠŸèƒ½**: è‡ªå‹•åµæ¸¬ä¸¦é¡¯ç¤º `localtunnel` çš„é€šé“å¯†ç¢¼ï¼Œç„¡éœ€     â•‘
# â•‘     ä½¿ç”¨è€…æ‰‹å‹•æŸ¥è©¢ã€‚                                               â•‘
# â•‘ - V28.1 æ›´æ–°æ—¥èªŒ (2025-09-16):                                       â•‘
# â•‘   - **å¢å¼·æ—¥èªŒ**: ç‚ºé‡‘é‘°è‡ªå‹•é©—è­‰æµç¨‹æ·»åŠ æ›´è©³ç´°çš„æ—¥èªŒè¨˜éŒ„ï¼Œä»¥ä¾¿è¿½è¹¤   â•‘
# â•‘     åŸ·è¡Œç‹€æ…‹ä¸¦è¨ºæ–·æ½›åœ¨å•é¡Œã€‚                                       â•‘
# â•‘ - V28 æ›´æ–°æ—¥èªŒ (2025-09-16):                                         â•‘
# â•‘   - **ä¿®å¾©é‡‘é‘°é©—è­‰**: èª¿æ•´é‡‘é‘°é©—è­‰æ™‚çš„å­ç¨‹åºç’°å¢ƒï¼Œè§£æ±ºé«˜éšç¡¬é«”ä¸Š     â•‘
# â•‘     å› ç’°å¢ƒè®Šæ•¸ä¸å®Œæ•´è€Œå°è‡´çš„é©—è­‰å¤±æ•—å•é¡Œã€‚                         â•‘
# â•‘   - **æ›´æ–°é è¨­åˆ†æ”¯**: å°‡é è¨­åˆ†æ”¯è™Ÿç¢¼æ›´æ–°ç‚º `25.4`ã€‚                  â•‘
# â•‘                                                                      â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#@title âœ¨ğŸº å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ (v50)  ğŸº { vertical-output: true, display-mode: "form" }
#@markdown ---
#@markdown ### **æ ¸å¿ƒè¨­å®š**
#@markdown > **è«‹ç¢ºèªä»¥ä¸‹å…©å€‹æ ¸å¿ƒè¨­å®šã€‚**
#@markdown ---
#@markdown **å¾Œç«¯ç‰ˆæœ¬åˆ†æ”¯æˆ–æ¨™ç±¤**
TARGET_BRANCH_OR_TAG = "141.2" #@param {type:"string"}
#@markdown **è‡ªå‹•å¾ Colab Secrets è¼‰å…¥çš„é‡‘é‘°æ•¸é‡ (0-20)**
#@markdown > è¼¸å…¥ `2` å°‡è¼‰å…¥ `GOOGLE_API_KEY`, `_1`, `_2` å…±ä¸‰çµ„é‡‘é‘°ã€‚
KEY_LOAD_COUNT_LIMIT = 2 #@param {type:"number"}
#@markdown **æ—¥èªŒé¡¯ç¤ºè¡Œæ•¸ (1-15)**
#@markdown > è¨­å®šå–®æ¢æ—¥èªŒåœ¨å„€è¡¨æ¿ä¸­ä½”æ“šçš„ç¸½è¡Œæ•¸ã€‚`1` ç‚ºå–®è¡Œç·Šæ¹Šæ¨¡å¼ï¼Œ`2-15` ç‚ºå¤šè¡Œæ¨¡å¼ã€‚
LOG_SPLIT_LINES = 2 #@param {type:"number"}
#@markdown ---
#@markdown > **è¨­å®šå®Œæˆå¾Œï¼Œé»æ“Šã€ŒåŸ·è¡Œã€æŒ‰éˆ•ã€‚**
#@markdown ---

# --- JULES'S NEW FEATURE (2025-09-30): åƒæ•¸é‚Šç•Œé©—è­‰ ---
# ç¢ºä¿ä½¿ç”¨è€…è¼¸å…¥çš„æ—¥èªŒè¡Œæ•¸åœ¨åˆç†ç¯„åœå…§ï¼Œé˜²æ­¢ä»‹é¢éŒ¯äº‚ã€‚
if not 1 <= LOG_SPLIT_LINES <= 15:
    print(f"âš ï¸ è­¦å‘Šï¼šæ—¥èªŒé¡¯ç¤ºè¡Œæ•¸è¨­å®šå€¼ ({LOG_SPLIT_LINES}) è¶…å‡ºæœ‰æ•ˆç¯„åœ (1-15)ã€‚å°‡è‡ªå‹•ä½¿ç”¨é è¨­å€¼ 2ã€‚")
    LOG_SPLIT_LINES = 2

# ==============================================================================
# SECTION A: é€²éšè¨­å®š (å¯åœ¨æ­¤è™•ä¿®æ”¹)
# èªªæ˜ï¼šä»¥ä¸‹ç‚ºä¸å¸¸è®Šå‹•çš„é€²éšè¨­å®šã€‚è‹¥éœ€èª¿æ•´ï¼Œè«‹ç›´æ¥ä¿®æ”¹æ­¤å€å¡Šçš„è®Šæ•¸å€¼ã€‚
# è¨­è¨ˆç†å¿µï¼šå°‡é«˜éšè¨­å®šèˆ‡ä½¿ç”¨è€…å¸¸ç”¨è¨­å®šåˆ†é›¢ï¼Œè®“å¤§å¤šæ•¸ä½¿ç”¨è€…åªéœ€é—œæ³¨ä¸Šæ–¹è¡¨å–®å³å¯ã€‚
# ==============================================================================

# Part 1: æ ¸å¿ƒå°ˆæ¡ˆè¨­å®š (å›ºå®š)
# Git å„²å­˜åº« URL
REPOSITORY_URL = "https://github.com/hsp1234-web/20250910.git"
# åœ¨ Colab æœ¬æ©Ÿä¸­å»ºç«‹çš„å°ˆæ¡ˆè³‡æ–™å¤¾åç¨±
PROJECT_FOLDER_NAME = "wolf_project"
# æ˜¯å¦åœ¨æ¯æ¬¡å•Ÿå‹•æ™‚ï¼Œéƒ½å¼·åˆ¶åˆªé™¤èˆŠçš„å°ˆæ¡ˆè³‡æ–™å¤¾ä¸¦é‡æ–° cloneã€‚è¨­ç‚º True å¯ç¢ºä¿ç¨‹å¼ç¢¼æ°¸é æ˜¯æœ€æ–°ç‰ˆã€‚
FORCE_REPO_REFRESH = True

# Part 1.5: é€šé“å•Ÿç”¨è¨­å®š
# å•Ÿç”¨ Colab å…§å»ºçš„ä»£ç†æœå‹™ï¼Œé€šå¸¸æœ€ç©©å®šã€‚
ENABLE_COLAB_PROXY = True
# å•Ÿç”¨ localtunnel ä½œç‚ºå‚™æ´é€šé“ã€‚
ENABLE_LOCALTUNNEL = True
# å•Ÿç”¨ Cloudflare Tunnel ä½œç‚ºå‚™æ´é€šé“ã€‚
ENABLE_CLOUDFLARE = True

# Part 2: å„€è¡¨æ¿èˆ‡ç›£æ§è¨­å®š
# ç´”æ–‡å­—å„€è¡¨æ¿çš„åˆ·æ–°é »ç‡ï¼ˆç§’ï¼‰ã€‚
UI_REFRESH_SECONDS = 0.5
# å„€è¡¨æ¿ä¸Šé¡¯ç¤ºçš„æ—¥èªŒè¡Œæ•¸ä¸Šé™ã€‚
LOG_DISPLAY_LINES = 5
# è¨­å®šç³»çµ±çš„æ™‚å€ï¼Œç¢ºä¿æ—¥èªŒæ™‚é–“æˆ³æ­£ç¢ºã€‚
TIMEZONE = "Asia/Taipei"

# Part 3: æ—¥èªŒç­‰ç´šå¯è¦‹æ€§
# æ§åˆ¶å“ªäº›ç­‰ç´šçš„æ—¥èªŒè¨Šæ¯æœƒé¡¯ç¤ºåœ¨å„€è¡¨æ¿ä¸Šã€‚
SHOW_LOG_LEVEL_BATTLE = True
SHOW_LOG_LEVEL_SUCCESS = True
SHOW_LOG_LEVEL_INFO = True
SHOW_LOG_LEVEL_WARN = True
SHOW_LOG_LEVEL_ERROR = True
SHOW_LOG_LEVEL_CRITICAL = True
SHOW_LOG_LEVEL_DEBUG = True

# Part 4: å ±å‘Šèˆ‡æ­¸æª”è¨­å®š
# è…³æœ¬åŸ·è¡ŒçµæŸå¾Œï¼Œè‡ªå‹•å„²å­˜æ—¥èªŒèˆ‡å ±å‘Šçš„æ ¹è³‡æ–™å¤¾åç¨±ã€‚
LOG_ARCHIVE_ROOT_FOLDER = "paper"
# ç­‰å¾…å¾Œç«¯ä¼ºæœå™¨å•Ÿå‹•çš„æœ€é•·ç§’æ•¸ï¼Œè¶…éæ­¤æ™‚é–“å‰‡è¦–ç‚ºå¤±æ•—ã€‚
SERVER_READY_TIMEOUT = 150
# æœ€çµ‚è¤‡è£½åˆ°å‰ªè²¼ç°¿æˆ–å ±å‘Šä¸­çš„æ—¥èªŒæœ€å¤§è¡Œæ•¸ã€‚
LOG_COPY_MAX_LINES = 5000

# ==============================================================================
# SECTION 0: ç’°å¢ƒæº–å‚™èˆ‡æ ¸å¿ƒä¾è³´å°å…¥ (æ­¤è™•é–‹å§‹ç‚ºæ ¸å¿ƒç¨‹å¼ï¼Œé€šå¸¸ç„¡éœ€ä¿®æ”¹)
# è¨­è¨ˆç†å¿µï¼šæ­¤å€å¡Šè² è²¬æ‰€æœ‰åŸºç¤è¨­å®šèˆ‡æ¨¡çµ„å°å…¥ï¼Œç¢ºä¿å¾ŒçºŒç¨‹å¼èƒ½é †åˆ©åŸ·è¡Œã€‚
# ==============================================================================
import sys
import subprocess
import socket
import platform
import urllib.request
# å˜—è©¦å°å…¥ pytzï¼Œå¦‚æœå¤±æ•—å‰‡è‡ªå‹•å®‰è£ã€‚é€™æ˜¯è™•ç†æ™‚å€æ‰€å¿…éœ€çš„å¥—ä»¶ã€‚
try:
    import pytz
except ImportError:
    print("æ­£åœ¨å®‰è£ pytz...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "pytz"])
    import pytz

import os
import shutil
from pathlib import Path
import time
from datetime import datetime
import threading
from collections import deque
import re
import json
import html
import requests
from IPython.display import clear_output, display, HTML
from google.colab import output as colab_output

# ==============================================================================
# SECTION 1: ç®¡ç†å™¨é¡åˆ¥å®šç¾© (Managers)
# è¨­è¨ˆç†å¿µï¼šæ¡ç”¨ç‰©ä»¶å°å‘çš„è¨­è¨ˆï¼Œå°‡ä¸åŒè·è²¬ï¼ˆæ—¥èªŒã€é¡¯ç¤ºã€ä¼ºæœå™¨ç®¡ç†ï¼‰å°è£åˆ°ç¨ç«‹çš„é¡åˆ¥ä¸­ï¼Œ
# ä½¿å¾—ç¨‹å¼ç¢¼çµæ§‹æ›´æ¸…æ™°ã€æ›´å®¹æ˜“ç¶­è­·ã€‚
# ==============================================================================

class LogManager:
    """æ—¥èªŒç®¡ç†å™¨ï¼šè² è²¬è¨˜éŒ„ã€éæ¿¾å’Œå„²å­˜æ‰€æœ‰æ—¥èªŒè¨Šæ¯ã€‚"""
    def __init__(self, max_lines, timezone_str, log_levels_to_show):
        # ä½¿ç”¨ deque å„²å­˜æ—¥èªŒï¼Œé€™æ˜¯ä¸€å€‹é›™å‘ä½‡åˆ—ï¼Œç•¶è¶…éæœ€å¤§è¡Œæ•¸æ™‚æœƒè‡ªå‹•ä¸Ÿæ£„èˆŠçš„æ—¥èªŒï¼Œæ•ˆç‡å¾ˆé«˜ã€‚
        self._log_deque = deque(maxlen=max_lines)
        # å„²å­˜å®Œæ•´çš„æ—¥èªŒæ­·å²ç´€éŒ„ï¼Œç”¨æ–¼æœ€å¾Œçš„å ±å‘Šç”Ÿæˆã€‚
        self._full_history = []
        # ä½¿ç”¨åŸ·è¡Œç·’é–ï¼Œç¢ºä¿åœ¨å¤šåŸ·è¡Œç·’ç’°å¢ƒä¸‹å°æ—¥èªŒçš„å­˜å–æ˜¯å®‰å…¨çš„ã€‚
        self._lock = threading.Lock()
        self.timezone = pytz.timezone(timezone_str)
        self.log_levels_to_show = log_levels_to_show

    def log(self, level: str, message: str, source: str = "SYSTEM"):
        """è¨˜éŒ„ä¸€æ¢æ–°çš„æ—¥èªŒã€‚"""
        with self._lock:
            log_entry = {"timestamp": datetime.now(self.timezone), "level": level.upper(), "message": str(message), "source": source}
            self._log_deque.append(log_entry)
            self._full_history.append(log_entry)

    def get_display_logs(self) -> list:
        """ç²å–éœ€è¦åœ¨å„€è¡¨æ¿ä¸Šé¡¯ç¤ºçš„æ—¥èªŒï¼ˆç¶“éç­‰ç´šéæ¿¾ï¼‰ã€‚"""
        with self._lock:
            all_logs = list(self._log_deque)
            # æ ¹æ“š Part 3 çš„è¨­å®šï¼Œéæ¿¾æ‰ä¸éœ€é¡¯ç¤ºçš„æ—¥èªŒç­‰ç´šã€‚
            return [log for log in all_logs if self.log_levels_to_show.get(f"SHOW_LOG_LEVEL_{log['level']}", False)]

    def get_full_history(self) -> list:
        """ç²å–å®Œæ•´çš„æ—¥èªŒæ­·å²ã€‚"""
        with self._lock:
            return self._full_history

# å®šç¾©ç”¨æ–¼åœ¨çµ‚ç«¯æ©Ÿä¸­é¡¯ç¤ºå½©è‰²æ–‡å­—çš„ ANSI escape codesã€‚
ANSI_COLORS = {
    "SUCCESS": "\033[32m", "WARN": "\033[33m", "ERROR": "\033[31m",
    "CRITICAL": "\033[31m", "RESET": "\033[0m"
}

def colorize(text, level):
    """æ ¹æ“šæ—¥èªŒç­‰ç´šï¼Œç‚ºæ–‡å­—æ·»åŠ é¡è‰²ã€‚"""
    return f"{ANSI_COLORS.get(level, '')}{text}{ANSI_COLORS['RESET']}"

class DisplayManager:
    """é¡¯ç¤ºç®¡ç†å™¨ï¼šåœ¨èƒŒæ™¯åŸ·è¡Œç·’ä¸­è² è²¬ç¹ªè£½ç´”æ–‡å­—å‹•æ…‹å„€è¡¨æ¿ã€‚"""
    def __init__(self, log_manager, stats_dict, refresh_rate):
        self._log_manager = log_manager
        # stats_dict æ˜¯ä¸€å€‹å…±äº«çš„å­—å…¸ï¼Œç”¨æ–¼åœ¨ä¸åŒç®¡ç†å™¨ä¹‹é–“å‚³éç‹€æ…‹è¨Šæ¯ï¼ˆä¾‹å¦‚ CPU ä½¿ç”¨ç‡ã€å…¬é–‹ç¶²å€ç­‰ï¼‰ã€‚
        self._stats = stats_dict
        self._refresh_rate = refresh_rate
        # ä½¿ç”¨ threading.Event ä¾†å„ªé›…åœ°åœæ­¢èƒŒæ™¯åŸ·è¡Œç·’ã€‚
        self._stop_event = threading.Event()
        # å°‡å„€è¡¨æ¿çš„ç¹ªè£½æ”¾åœ¨ä¸€å€‹ç¨ç«‹çš„ daemon åŸ·è¡Œç·’ä¸­ï¼Œé€™æ¨£ä¸»ç¨‹å¼é€€å‡ºæ™‚å®ƒä¹Ÿæœƒè‡ªå‹•é€€å‡ºã€‚
        self._thread = threading.Thread(target=self._run, daemon=True)

    def _build_output_buffer(self) -> list[str]:
        """å»ºç«‹å„€è¡¨æ¿çš„æ¯ä¸€å¹€ç•«é¢å…§å®¹ã€‚"""
        output_buffer = ["âœ¨ğŸº å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ (v50) ğŸº", ""]
        logs_to_display = self._log_manager.get_display_logs()

        # æ—¥èªŒæ ¼å¼åŒ–é‚è¼¯
        for log in logs_to_display:
            ts = log['timestamp'].strftime('%H:%M:%S')
            level, msg = log['level'], log['message']

            if LOG_SPLIT_LINES == 1:
                # --- å–®è¡Œç·Šæ¹Šæ¨¡å¼ ---
                output_buffer.append(f"[{ts}] {colorize(f'[{level:^8}]', level)} {msg}")
            else:
                # --- å¤šè¡Œèˆ’é©æ¨¡å¼ ---
                # ç¬¬ä¸€è¡Œé¡¯ç¤ºæ™‚é–“å’Œç­‰ç´š
                header = f"[{ts}] {colorize(f'[{level:^8}]', level)}"
                output_buffer.append(header)

                # å¾ŒçºŒè¡Œé¡¯ç¤ºè¨Šæ¯æœ¬æ–‡ï¼Œä¸¦æ ¹æ“šè¨­å®šçš„è¡Œæ•¸è‡ªå‹•æ›è¡Œ
                num_message_lines = max(1, LOG_SPLIT_LINES - 1)

                if not msg:
                    continue

                avg_len = len(msg) / num_message_lines
                start_index = 0
                for i in range(num_message_lines):
                    if start_index >= len(msg):
                        break
                    end_index = len(msg) if i == num_message_lines - 1 else int(start_index + avg_len + 0.5)
                    line_content = msg[start_index:end_index].strip()
                    if line_content:
                        output_buffer.append(line_content)
                    start_index = end_index

        # é¡¯ç¤ºæ‰€æœ‰ä»£ç†é€šé“çš„å…¬é–‹ç¶²å€
        urls = self._stats.get('urls', {})
        if urls:
            if logs_to_display: output_buffer.append("")
            output_buffer.append("ğŸ”— å…¬é–‹å­˜å–ç¶²å€ (Public URLs):")
            # æ ¹æ“š priority æ’åºï¼Œè®“æœ€ç©©å®šçš„é€šé“é¡¯ç¤ºåœ¨æœ€å‰é¢ã€‚
            sorted_urls = sorted(urls.items(), key=lambda item: item[1].get('priority', 99))
            for name, url_info in sorted_urls:
                if url_info['status'] == 'ready':
                    line = f"  - {name}: {colorize(url_info['url'], 'SUCCESS')}"
                    if 'password' in url_info:
                        line += f" (å¯†ç¢¼: {url_info['password']})"
                    output_buffer.append(line)
                elif url_info['status'] == 'starting':
                    output_buffer.append(f"  - {name}: æ­£åœ¨å•Ÿå‹•ä¸­...")
                else:
                    output_buffer.append(f"  - {name}: {colorize(url_info.get('error', 'ç™¼ç”ŸéŒ¯èª¤'), 'ERROR')}")

        # é¡¯ç¤ºç³»çµ±è³‡æºä½¿ç”¨ç‡å’ŒåŸ·è¡Œæ™‚é–“
        try:
            import psutil
            cpu, ram = f"{psutil.cpu_percent():5.1f}%", f"{psutil.virtual_memory().percent:5.1f}%"
        except ImportError:
            cpu, ram = "  N/A ", "  N/A "
        elapsed = time.monotonic() - self._stats.get("start_time_monotonic", time.monotonic())
        mins, secs = divmod(elapsed, 60)
        output_buffer.append("")
        output_buffer.append(f"â±ï¸ {int(mins):02d}åˆ†{int(secs):02d}ç§’ | ğŸ’» CPU: {cpu} | ğŸ§  RAM: {ram} | ğŸ”¥ ç‹€æ…‹: {self._stats.get('status', 'åˆå§‹åŒ–...')}")
        return output_buffer

    def _run(self):
        """èƒŒæ™¯åŸ·è¡Œç·’çš„ä¸»å¾ªç’°ï¼Œå®šæœŸé‡ç¹ªå„€è¡¨æ¿ã€‚"""
        while not self._stop_event.is_set():
            try:
                # æ¸…é™¤èˆŠçš„è¼¸å‡ºï¼Œç„¶å¾Œå°å‡ºæ–°çš„ç•«é¢
                clear_output(wait=True)
                print("\n".join(self._build_output_buffer()), flush=True)
                time.sleep(self._refresh_rate)
            except Exception as e:
                self._log_manager.log("ERROR", f"DisplayManager åŸ·è¡Œç·’ç™¼ç”ŸéŒ¯èª¤: {e}")
                time.sleep(5)

    def start(self): self._thread.start()
    def stop(self): self._stop_event.set(); self._thread.join(timeout=2)

class ServerManager:
    """ä¼ºæœå™¨ç®¡ç†å™¨ï¼šè² è²¬å•Ÿå‹•ã€åœæ­¢å’Œç›£æ§å¾Œç«¯ä¼ºæœå™¨å­é€²ç¨‹ã€‚"""
    def __init__(self, log_manager, stats_dict):
        self._log_manager = log_manager; self._stats = stats_dict
        self.server_process = None; self.server_ready_event = threading.Event()
        self._stop_event = threading.Event()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self.port = None

    def _ensure_uv_installed(self):
        """æª¢æŸ¥ `uv` (ä¸€å€‹å¿«é€Ÿçš„ Python å¥—ä»¶å®‰è£å™¨) æ˜¯å¦å·²å®‰è£ï¼Œè‹¥å¦ï¼Œå‰‡å˜—è©¦å®‰è£ã€‚"""
        try:
            subprocess.check_call([sys.executable, "-m", "uv", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self._log_manager.log("INFO", "âœ… 'uv' åŠ é€Ÿå™¨å·²å®‰è£ã€‚")
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            self._log_manager.log("INFO", "æœªæ‰¾åˆ° 'uv'ï¼Œæ­£åœ¨å˜—è©¦å®‰è£...")
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "uv"])
                self._log_manager.log("SUCCESS", "âœ… 'uv' åŠ é€Ÿå™¨å®‰è£æˆåŠŸï¼")
                return True
            except subprocess.CalledProcessError:
                self._log_manager.log("WARN", "å®‰è£ 'uv' å¤±æ•—ï¼Œå°‡é€€å›ä½¿ç”¨ 'pip'ã€‚")
                return False

    def _inject_keys_background(self, project_path: Path):
        """
        [èƒŒæ™¯åŸ·è¡Œ] è² è²¬å¾ Colab Secrets (ä¸€å€‹å®‰å…¨å„²å­˜æ•æ„Ÿè³‡è¨Šçš„åœ°æ–¹) ç²å–é‡‘é‘°ä¸¦é€éè…³æœ¬æ³¨å…¥åˆ°æ‡‰ç”¨ç¨‹å¼ä¸­ã€‚
        """
        self._log_manager.log("INFO", "[èƒŒæ™¯] é–‹å§‹åŸ·è¡Œé‡‘é‘°æ³¨å…¥...")
        try:
            # æ ¸å¿ƒé‡‘é‘°æ³¨å…¥é‚è¼¯ï¼š
            # åœ¨ Colab ä¸­ï¼Œåªæœ‰ä¸»åŸ·è¡Œç·’æ‰èƒ½å­˜å– Secretsã€‚å› æ­¤ï¼Œæˆ‘å€‘åœ¨ä¸»åŸ·è¡Œç·’ä¸­ç²å–æ‰€æœ‰é‡‘é‘°ï¼Œ
            # ç„¶å¾Œé€éå‘½ä»¤åˆ—åƒæ•¸å®‰å…¨åœ°å‚³éçµ¦ä¸€å€‹ç¨ç«‹çš„å­ç¨‹åºï¼ˆkey_injector_scriptï¼‰ä¾†åŸ·è¡Œæ³¨å…¥æ“ä½œã€‚
            key_injector_script = project_path / "scripts" / "colab_key_injector.py"
            if not key_injector_script.is_file():
                self._log_manager.log("WARN", f"[èƒŒæ™¯] æœªæ‰¾åˆ°é‡‘é‘°æ³¨å…¥è…³æœ¬ '{key_injector_script}'ï¼Œè·³éé‡‘é‘°è¼‰å…¥ã€‚")
                return

            from google.colab import userdata
            self._log_manager.log("INFO", "[èƒŒæ™¯] æ­£åœ¨å¾ Colab Secrets ç²å–é‡‘é‘°...")

            # æ ¹æ“šä½¿ç”¨è€…åœ¨è¡¨å–®ä¸­çš„è¨­å®šï¼Œæ±ºå®šè¦è®€å–å¤šå°‘å€‹é‡‘é‘°ã€‚
            base_key_name = "GOOGLE_API_KEY"
            target_key_names = [base_key_name]
            if KEY_LOAD_COUNT_LIMIT > 0:
                target_key_names.extend([f"{base_key_name}_{i}" for i in range(1, KEY_LOAD_COUNT_LIMIT + 1)])

            keys_to_inject = []
            for key_name in target_key_names:
                try:
                    key_value = userdata.get(key_name)
                    if key_value and key_value.strip():
                        keys_to_inject.append(key_value)
                        self._log_manager.log("INFO", f"[èƒŒæ™¯] âœ… å·²æˆåŠŸç²å–é‡‘é‘° '{key_name}'ã€‚")
                except userdata.SecretNotFoundError:
                    self._log_manager.log("INFO", f"[èƒŒæ™¯] ğŸŸ¡ æœªåœ¨ Colab Secrets ä¸­æ‰¾åˆ°é‡‘é‘° '{key_name}'ï¼Œè·³éã€‚")
                except Exception as e:
                    self._log_manager.log("WARN", f"[èƒŒæ™¯] è®€å–é‡‘é‘° '{key_name}' æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}ï¼Œè·³éã€‚")

            if not keys_to_inject:
                 self._log_manager.log("WARN", "[èƒŒæ™¯] æœªå¾ Colab Secrets ä¸­ç²å–åˆ°ä»»ä½•é‡‘é‘°ï¼Œè·³éæ³¨å…¥ã€‚")
                 return

            # å°‡æ‰€æœ‰é‡‘é‘°åˆä½µæˆä¸€å€‹å­—ä¸²ï¼Œæº–å‚™å‚³éçµ¦å­ç¨‹åºã€‚
            keys_string = "\n".join(keys_to_inject)
            command = [
                sys.executable, str(key_injector_script.resolve()),
                "--mode", "manual", "--manual-keys", keys_string
            ]

            # åŒæ¨£åœ°ï¼Œå®‰å…¨åœ°è®€å–ä¸¦å‚³é FRED API é‡‘é‘°ã€‚
            fred_api_key = None
            try:
                fred_api_key = userdata.get('FRED_API_KEY')
                if fred_api_key and fred_api_key.strip():
                    command.extend(["--fred-key", fred_api_key])
                    self._log_manager.log("INFO", "[èƒŒæ™¯] æˆåŠŸè®€å– FRED_API_KEY ä¸¦æº–å‚™é€éåƒæ•¸å‚³éã€‚", "KeyInjector")
            except Exception:
                self._log_manager.log("WARN", "[èƒŒæ™¯] æœªèƒ½åœ¨ Colab Secrets ä¸­æ‰¾åˆ° FRED_API_KEYã€‚", "KeyInjector")

            # åŸ·è¡Œæ³¨å…¥è…³æœ¬ï¼Œä¸¦å³æ™‚è®€å–å…¶è¼¸å‡ºï¼Œé¡¯ç¤ºåœ¨ä¸»å„€è¡¨æ¿ä¸Šã€‚
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
            for line in iter(process.stdout.readline, ''):
                self._log_manager.log("INFO", f"[èƒŒæ™¯] {line.strip()}", "KeyInjector")
            process.wait()

            if process.returncode == 0:
                self._log_manager.log("SUCCESS", "[èƒŒæ™¯] âœ… é‡‘é‘°æ³¨å…¥è…³æœ¬åŸ·è¡Œå®Œç•¢ã€‚")
            else:
                self._log_manager.log("WARN", f"[èƒŒæ™¯] é‡‘é‘°æ³¨å…¥è…³æœ¬åŸ·è¡ŒçµæŸï¼Œä½†è¿”å›ç¢¼ç‚º {process.returncode}ã€‚")

        except ImportError:
            self._log_manager.log("WARN", "[èƒŒæ™¯] ç„¡æ³•åŒ¯å…¥ google.colab.userdataï¼Œå¯èƒ½ä¸¦éåœ¨ Colab ç’°å¢ƒã€‚è·³éé‡‘é‘°æ³¨å…¥ã€‚")
        except Exception as e:
            self._log_manager.log("ERROR", f"[èƒŒæ™¯] åŸ·è¡Œé‡‘é‘°æ³¨å…¥æ™‚ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤: {e}")
        finally:
            self._log_manager.log("INFO", "[èƒŒæ™¯] é‡‘é‘°æ³¨å…¥åŸ·è¡Œç·’çµæŸã€‚")


    def _run(self):
        """ä¼ºæœå™¨ç®¡ç†åŸ·è¡Œç·’çš„ä¸»é«”ï¼Œè² è²¬æ•´å€‹å•Ÿå‹•æµç¨‹ã€‚"""
        try:
            self._log_manager.log("BATTLE", "=== å•Ÿå‹•å™¨æ ¸å¿ƒæµç¨‹é–‹å§‹ ===")
            self._stats['status'] = "ğŸš€ æº–å‚™åŸ·è¡Œç’°å¢ƒ..."

            # æ­¥é©Ÿ 1: ä¸‹è¼‰æˆ–æ›´æ–°ç¨‹å¼ç¢¼
            project_path = Path(PROJECT_FOLDER_NAME)
            if FORCE_REPO_REFRESH and project_path.exists():
                self._log_manager.log("INFO", f"åµæ¸¬åˆ°èˆŠçš„å°ˆæ¡ˆè³‡æ–™å¤¾ '{project_path}'ï¼Œæ­£åœ¨å¼·åˆ¶åˆªé™¤...")
                shutil.rmtree(project_path)

            self._log_manager.log("INFO", f"æ­£åœ¨å¾ Git ä¸‹è¼‰ (åˆ†æ”¯: {TARGET_BRANCH_OR_TAG})...")
            git_command = ["git", "clone", "--branch", TARGET_BRANCH_OR_TAG, "--depth", "1", REPOSITORY_URL, str(project_path)]
            result = subprocess.run(git_command, check=False, capture_output=True, text=True, encoding='utf-8')
            if result.returncode != 0:
                error_message = f"""Git clone å¤±æ•—! è¿”å›ç¢¼: {result.returncode}\n--- STDOUT ---\n{result.stdout}\n--- STDERR ---\n{result.stderr}\n"""
                self._log_manager.log("CRITICAL", error_message)
                return
            self._log_manager.log("INFO", "âœ… Git å€‰åº«ä¸‹è¼‰å®Œæˆã€‚")
            self._log_manager.log("INFO", f"--- Git Clone å®Œæˆ (è€—æ™‚: {time.monotonic() - self._stats.get('start_time_monotonic', 0):.2f} ç§’) ---")

            # å°‡å°ˆæ¡ˆçš„ src ç›®éŒ„åŠ å…¥åˆ° Python çš„æœå°‹è·¯å¾‘ä¸­ï¼Œé€™æ¨£æ‰èƒ½æ­£ç¢ºå°å…¥å°ˆæ¡ˆå…§çš„æ¨¡çµ„ã€‚
            project_src_path = project_path / "src"
            project_src_path_str = str(project_src_path.resolve())
            if project_src_path_str not in sys.path:
                sys.path.insert(0, project_src_path_str)

            # æ­¥é©Ÿ 2: åˆå§‹åŒ–è³‡æ–™åº«
            self._log_manager.log("INFO", "ğŸ”© æ­¥é©Ÿ 1/5: æ­£åœ¨åˆå§‹åŒ–è³‡æ–™åº«çµæ§‹...")
            try:
                # å‹•æ…‹å°å…¥è³‡æ–™åº«åˆå§‹åŒ–è…³æœ¬ä¸¦åŸ·è¡Œã€‚
                from db import initialize_database as key_db_init
                from io import StringIO
                import contextlib
                init_log_stream = StringIO()
                with contextlib.redirect_stdout(init_log_stream):
                    key_db_init.initialize()
                init_logs = init_log_stream.getvalue().strip()
                if init_logs:
                    for line in init_logs.split('\n'):
                        self._log_manager.log("INFO", f"[DB_Init] {line}", "Database")
                self._log_manager.log("SUCCESS", "âœ… é‡‘é‘°è³‡æ–™åº«çµæ§‹å·²æ˜¯æœ€æ–°ç‰ˆæœ¬ã€‚")

                from db.database import initialize_database as task_db_init, add_system_log
                task_db_init()
                add_system_log("colab_setup", "INFO", "Git repository cloned and DB schema updated.")
                self._log_manager.log("INFO", "âœ… èˆŠç‰ˆä»»å‹™è³‡æ–™åº«åˆå§‹åŒ–æˆåŠŸã€‚")
            except Exception as e:
                self._log_manager.log("CRITICAL", f"è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—ï¼Œé€™æ˜¯ä¸€å€‹è‡´å‘½éŒ¯èª¤ï¼Œå•Ÿå‹•ä¸­æ­¢ã€‚ {e}", "Database")
                return

            # æ­¥é©Ÿ 3: å®‰è£ Python ä¾è³´å¥—ä»¶
            def force_install_packages(req_file: Path, log_prefix: str):
                """ä¸€å€‹ç°¡åŒ–çš„å®‰è£å‡½å¼ï¼Œä¸æª¢æŸ¥ï¼Œç›´æ¥å®‰è£ã€‚å„ªå…ˆä½¿ç”¨ uv åŠ é€Ÿå™¨ã€‚"""
                if not req_file.is_file():
                    self._log_manager.log("WARN", f"[{log_prefix}] ä¾è³´æª”æ¡ˆ '{req_file.name}' ä¸å­˜åœ¨ï¼Œè·³éã€‚")
                    return
                self._log_manager.log("INFO", f"[{log_prefix}] é–‹å§‹å¼·åˆ¶å®‰è£ä¾è³´...")
                install_start_time = time.monotonic()
                try:
                    use_uv = self._ensure_uv_installed()
                    if use_uv:
                        pip_command = [sys.executable, "-m", "uv", "pip", "install", "--system", "-r", str(req_file.resolve())]
                        self._log_manager.log("INFO", f"[{log_prefix}] ä½¿ç”¨ 'uv' é€²è¡Œå¿«é€Ÿå¼·åˆ¶å®‰è£...")
                    else:
                        pip_command = [sys.executable, "-m", "pip", "install", "-r", str(req_file.resolve())]
                        self._log_manager.log("INFO", f"[{log_prefix}] ä½¿ç”¨ 'pip' é€²è¡Œå¼·åˆ¶å®‰è£ã€‚")
                    result = subprocess.run(pip_command, capture_output=True, text=True, encoding='utf-8')
                    if result.stdout and result.stdout.strip():
                        self._log_manager.log("DEBUG", f"[{log_prefix}] å®‰è£ç¨‹å¼ stdout:\n{result.stdout}", "Installer")
                    if result.returncode != 0:
                        error_log = f"å®‰è£å¤±æ•—ï¼è¿”å›ç¢¼: {result.returncode}\n"
                        if result.stderr and result.stderr.strip(): error_log += f"STDERR:\n{result.stderr}\n"
                        self._log_manager.log("ERROR", error_log, "Installer")
                        raise subprocess.CalledProcessError(result.returncode, pip_command, output=result.stdout, stderr=result.stderr)
                    self._log_manager.log("SUCCESS", f"âœ… [{log_prefix}] å¼·åˆ¶ä¾è³´å®‰è£å®Œæˆã€‚")
                    self._log_manager.log("INFO", f"--- [{log_prefix}] å®‰è£è€—æ™‚: {time.monotonic() - install_start_time:.2f} ç§’ ---")
                except subprocess.CalledProcessError as e:
                    self._log_manager.log("CRITICAL", f"[{log_prefix}] å¼·åˆ¶ä¾è³´å®‰è£å¤±æ•—ï¼", "Installer")
                    raise

            # å¼·åˆ¶å®‰è£æ‰€æœ‰æ ¸å¿ƒæœå‹™æ‰€éœ€çš„ä¾è³´ã€‚
            self._log_manager.log("INFO", "æ­¥é©Ÿ 1/4 & 2/4: æ­£åœ¨å¼·åˆ¶å®‰è£æ‰€æœ‰æ ¸å¿ƒæœå‹™ä¾è³´...")
            essential_req_files = {
                "ä¸‹è¼‰å™¨": project_path / "requirements" / "downloader.txt",
                "æ ¸å¿ƒæœå‹™": project_path / "requirements" / "core.txt",
                "åˆ†æåŠŸèƒ½": project_path / "requirements" / "analysis.txt",
                "å•Ÿå‹•å™¨æ ¸å¿ƒ": project_path / "requirements" / "features_core.txt",
            }
            for name, req_file in essential_req_files.items():
                force_install_packages(req_file, name)
            self._log_manager.log("SUCCESS", "âœ… æ‰€æœ‰æ ¸å¿ƒä¾è³´å®‰è£å®Œç•¢ã€‚")

            # æ­¥é©Ÿ 4: åœ¨èƒŒæ™¯å•Ÿå‹•é‡‘é‘°æ³¨å…¥ç¨‹åº
            # å°‡é‡‘é‘°æ³¨å…¥æ“ä½œç§»è‡³ä¾è³´å®‰è£å®Œæˆå¾Œï¼Œä»¥è§£æ±º ModuleNotFoundError çš„æ™‚åºå•é¡Œã€‚
            key_thread = threading.Thread(target=self._inject_keys_background, args=(project_path,), daemon=True)
            key_thread.start()

            # æ­¥é©Ÿ 5: å•Ÿå‹•å¾Œç«¯ä¼ºæœå™¨
            self._log_manager.log("INFO", "æ­¥é©Ÿ 3/4: æ­£åœ¨å•Ÿå‹•å¾Œç«¯å”èª¿å™¨...")
            launch_command = [sys.executable, "src/core/orchestrator.py"]
            process_env = os.environ.copy()
            src_path_str = str((project_path / "src").resolve())
            process_env['PYTHONPATH'] = f"{src_path_str}{os.pathsep}{process_env.get('PYTHONPATH', '')}".strip(os.pathsep)

            # å®‰å…¨åœ°å°‡ FRED API é‡‘é‘°æ³¨å…¥åˆ°ä¼ºæœå™¨çš„ç’°å¢ƒè®Šæ•¸ä¸­ã€‚
            try:
                from google.colab import userdata
                fred_api_key = userdata.get('FRED_API_KEY')
                if fred_api_key:
                    process_env['FRED_API_KEY'] = fred_api_key
                    self._log_manager.log("SUCCESS", "âœ… æˆåŠŸå¾ Colab Secrets è®€å–ä¸¦æ³¨å…¥ FRED_API_KEYã€‚")
                else:
                    self._log_manager.log("WARN", "ğŸŸ¡ åœ¨ Colab Secrets ä¸­æ‰¾åˆ° FRED_API_KEYï¼Œä½†å…¶å€¼ç‚ºç©ºã€‚")
            except (ImportError, userdata.SecretNotFoundError):
                self._log_manager.log("WARN", "ğŸŸ¡ æœªåœ¨ Colab Secrets ä¸­æ‰¾åˆ° FRED_API_KEYï¼Œéƒ¨åˆ†åœ–è¡¨å¯èƒ½ç„¡æ³•é¡¯ç¤ºã€‚")
            except Exception as e:
                self._log_manager.log("ERROR", f"è®€å– FRED_API_KEY æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

            # ä½¿ç”¨ Popen å•Ÿå‹•å¾Œç«¯ä¼ºæœå™¨å­é€²ç¨‹ã€‚
            self.server_process = subprocess.Popen(launch_command, cwd=str(project_path), stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8', preexec_fn=os.setsid, env=process_env)

            # æ­¥é©Ÿ 6: ç›£è½ä¼ºæœå™¨æ—¥èªŒï¼Œç­‰å¾…å…¶å°±ç·’
            self._log_manager.log("INFO", "æ­¥é©Ÿ 4/4: ç­‰å¾…å¾Œç«¯ä¼ºæœå™¨å°±ç·’...")
            port_pattern = re.compile(r"PROXY_URL: http://127.0.0.1:(\d+)")
            uvicorn_ready_pattern = re.compile(r"Uvicorn running on")
            server_ready = False

            # é€è¡Œè®€å–ä¼ºæœå™¨çš„è¼¸å‡ºæ—¥èªŒã€‚
            for line in iter(self.server_process.stdout.readline, ''):
                if self._stop_event.is_set(): break
                line = line.strip()
                self._log_manager.log("DEBUG", line)
                # å¾æ—¥èªŒä¸­è§£æå‡ºä¼ºæœå™¨é‹è¡Œçš„åŸ è™Ÿã€‚
                if not self.port and (match := port_pattern.search(line)):
                    self.port = int(match.group(1))
                    self._log_manager.log("INFO", f"âœ… å¾æ—¥èªŒä¸­æˆåŠŸè§£æå‡º API åŸ è™Ÿ: {self.port}")
                # åµæ¸¬åˆ° "Uvicorn running on" å­—æ¨£ï¼Œè¡¨ç¤ºä¼ºæœå™¨å·²æˆåŠŸå•Ÿå‹•ã€‚
                if not server_ready and uvicorn_ready_pattern.search(line):
                    server_ready = True
                    self._stats['status'] = "âœ… ä¼ºæœå™¨é‹è¡Œä¸­"
                    self._log_manager.log("SUCCESS", f"âœ… ä¼ºæœå™¨å·²å°±ç·’ï¼ (ç¸½è€—æ™‚: {time.monotonic() - self._stats.get('start_time_monotonic', 0):.2f} ç§’)")
                # ç•¶åŸ è™Ÿå’Œå°±ç·’ä¿¡è™Ÿéƒ½ç²å–åˆ°å¾Œï¼Œè§¸ç™¼äº‹ä»¶ï¼Œé€šçŸ¥å…¶ä»–ç®¡ç†å™¨å¯ä»¥é–‹å§‹å·¥ä½œäº†ã€‚
                if self.port and server_ready:
                    self.server_ready_event.set()

            return_code = self.server_process.wait()
            if not self.server_ready_event.is_set():
                self._stats['status'] = "âŒ ä¼ºæœå™¨å•Ÿå‹•å¤±æ•—"
                self._log_manager.log("CRITICAL", f"å”èª¿å™¨é€²ç¨‹åœ¨å°±ç·’å‰å·²çµ‚æ­¢ï¼Œè¿”å›ç¢¼: {return_code}ã€‚è«‹æª¢æŸ¥æ—¥èªŒã€‚")
        except Exception as e: self._stats['status'] = "âŒ ç™¼ç”Ÿè‡´å‘½éŒ¯èª¤"; self._log_manager.log("CRITICAL", f"ServerManager åŸ·è¡Œç·’å‡ºéŒ¯: {e}")
        finally: self._stats['status'] = "â¹ï¸ å·²åœæ­¢"

    def start(self): self._thread.start()
    def stop(self):
        """å„ªé›…åœ°åœæ­¢ä¼ºæœå™¨å­é€²ç¨‹ã€‚"""
        self._stop_event.set()
        if self.server_process and self.server_process.poll() is None:
            self._log_manager.log("INFO", "æ­£åœ¨çµ‚æ­¢ä¼ºæœå™¨é€²ç¨‹...")
            try:
                # ä½¿ç”¨ os.killpg ä¾†ç¢ºä¿èƒ½çµ‚æ­¢æ•´å€‹é€²ç¨‹çµ„ï¼Œé¿å…æ®­å±é€²ç¨‹ã€‚
                os.killpg(os.getpgid(self.server_process.pid), subprocess.signal.SIGTERM)
                self.server_process.wait(timeout=5)
            except (ProcessLookupError, subprocess.TimeoutExpired):
                try: os.killpg(os.getpgid(self.server_process.pid), subprocess.signal.SIGKILL)
                except ProcessLookupError: pass
        self._thread.join(timeout=2)

class TunnelManager:
    """é€šé“ç®¡ç†å™¨ï¼šä¸¦è¡Œå•Ÿå‹•å¤šå€‹ä»£ç†é€šé“ (Cloudflare, Localtunnel) ä»¥æä¾›å‚™æ´ï¼Œå¢åŠ é€£ç·šæˆåŠŸç‡ã€‚"""
    def __init__(self, log_manager, stats_dict, port):
        self._log = log_manager.log; self._stats = stats_dict; self._port = port
        self._stop_event = threading.Event(); self._threads = []; self._processes = []

    def start(self):
        """ä¸¦è¡Œå•Ÿå‹•æ‰€æœ‰å·²å•Ÿç”¨çš„é€šé“ã€‚"""
        if ENABLE_CLOUDFLARE: self._start_thread(self._run_cloudflared, "Cloudflare")
        if ENABLE_LOCALTUNNEL: self._start_thread(self._run_localtunnel, "Localtunnel")
        if ENABLE_COLAB_PROXY: self._start_thread(self._run_colab_proxy, "Colab")

    def _start_thread(self, target, name):
        thread = threading.Thread(target=target, name=name, daemon=True)
        self._threads.append(thread); thread.start()

    def _update_url_status(self, name, status, url=None, error=None, priority=99, password=None):
        """æ›´æ–°å…±äº«ç‹€æ…‹å­—å…¸ä¸­çš„ URL ç‹€æ…‹ã€‚"""
        with self._stats.get('_lock', threading.Lock()):
            entry = {"status": status, "priority": priority}
            if url: entry["url"] = url
            if error: entry["error"] = error
            if password: entry["password"] = password
            self._stats.setdefault('urls', {})[name] = entry

    def _ensure_cloudflared_installed(self):
        """æª¢æŸ¥ä¸¦å®‰è£ Cloudflare Tunnel å®¢æˆ¶ç«¯ã€‚"""
        if Path("./cloudflared").is_file(): return True
        self._log("INFO", "æœªæ‰¾åˆ° Cloudflaredï¼Œæ­£åœ¨ä¸‹è¼‰...", "Cloudflare")
        arch = platform.machine()
        url = f"https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-{'amd64' if arch == 'x86_64' else 'arm64'}"
        try:
            urllib.request.urlretrieve(url, "cloudflared"); os.chmod("cloudflared", 0o755)
            self._log("SUCCESS", "âœ… Cloudflared ä¸‹è¼‰æˆåŠŸã€‚", "Cloudflare"); return True
        except Exception as e: self._log("ERROR", f"Cloudflared ä¸‹è¼‰å¤±æ•—: {e}", "Cloudflare"); return False

    def _run_cloudflared(self):
        """å•Ÿå‹• Cloudflare Tunnelã€‚"""
        self._update_url_status("Cloudflare", "starting", priority=2)
        if not self._ensure_cloudflared_installed(): self._update_url_status("Cloudflare", "error", error="å®‰è£å¤±æ•—"); return
        proc = subprocess.Popen(["./cloudflared", "tunnel", "--url", f"http://127.0.0.1:{self._port}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
        self._processes.append(proc)
        url_pattern = re.compile(r"https://[a-zA-Z0-9-]+\.trycloudflare\.com")
        for line in iter(proc.stdout.readline, ''):
            if self._stop_event.is_set(): break
            self._log("DEBUG", line.strip(), "Cloudflare")
            if match := url_pattern.search(line):
                self._update_url_status("Cloudflare", "ready", url=match.group(0), priority=2); return
        if not self._stop_event.is_set(): self._update_url_status("Cloudflare", "error", error="ç„¡æ³•å¾æ—¥èªŒä¸­è§£æ URL")

    def _ensure_localtunnel_installed(self):
        """æª¢æŸ¥ä¸¦å®‰è£ Localtunnelã€‚"""
        if "localtunnel@" in subprocess.run(["npm", "list", "-g", "localtunnel"], capture_output=True, text=True).stdout: return True
        self._log("INFO", "æ­£åœ¨å®‰è£ Localtunnel...", "Localtunnel")
        try:
            subprocess.run(["npm", "install", "-g", "localtunnel"], check=True, capture_output=True)
            self._log("SUCCESS", "âœ… Localtunnel å®‰è£æˆåŠŸã€‚", "Localtunnel"); return True
        except subprocess.CalledProcessError as e: self._log("ERROR", f"Localtunnel å®‰è£å¤±æ•—: {e.stderr}", "Localtunnel"); return False

    def _run_localtunnel(self):
        """å•Ÿå‹• Localtunnel ä¸¦è‡ªå‹•ç²å–é€šé“å¯†ç¢¼ã€‚"""
        self._update_url_status("Localtunnel", "starting", priority=3)
        if not self._ensure_localtunnel_installed(): self._update_url_status("Localtunnel", "error", error="å®‰è£å¤±æ•—"); return
        proc = subprocess.Popen(["npx", "localtunnel", "--port", str(self._port)], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
        self._processes.append(proc)
        url_pattern = re.compile(r"your url is: (https://[a-zA-Z0-9-]+\.loca\.lt)")
        for line in iter(proc.stdout.readline, ''):
            if self._stop_event.is_set(): break
            self._log("DEBUG", line.strip(), "Localtunnel")
            if match := url_pattern.search(line):
                tunnel_url = match.group(1)
                self._log("INFO", f"âœ… Localtunnel URL '{tunnel_url}' å·²ç²å–ï¼Œæ­£åœ¨æŸ¥è©¢é€šé“å¯†ç¢¼...", "Localtunnel")
                password = "æŸ¥è©¢ä¸­..."
                try:
                    # è‡ªå‹•è¨ªå• loca.lt/mytunnelpassword ä¾†ç²å–ç•¶å‰ IP çš„é€šé“å¯†ç¢¼ã€‚
                    result = subprocess.run(["curl", "https://loca.lt/mytunnelpassword"], capture_output=True, text=True, timeout=10, check=True)
                    password = result.stdout.strip()
                    self._log("SUCCESS", f"âœ… å·²æˆåŠŸç²å– Localtunnel å¯†ç¢¼ã€‚", "Localtunnel")
                except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError) as e:
                    self._log("WARN", f"æŸ¥è©¢ Localtunnel å¯†ç¢¼å¤±æ•—: {e}", "Localtunnel"); password = "æŸ¥è©¢å¤±æ•—"
                except Exception as e:
                    self._log("ERROR", f"æŸ¥è©¢ Localtunnel å¯†ç¢¼æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}", "Localtunnel"); password = "æœªçŸ¥éŒ¯èª¤"
                self._update_url_status("Localtunnel", "ready", url=tunnel_url, password=password, priority=3)
                return
        if not self._stop_event.is_set(): self._update_url_status("Localtunnel", "error", error="ç„¡æ³•å¾æ—¥èªŒä¸­è§£æ URL")

    def _run_colab_proxy(self):
        """å•Ÿå‹• Colab å…§å»ºçš„ä»£ç†æœå‹™ã€‚"""
        self._update_url_status("Colab", "starting", priority=1)
        for attempt in range(10): # å¢åŠ é‡è©¦æ©Ÿåˆ¶ï¼Œå› ç‚º Colab ä»£ç†æœ‰æ™‚éœ€è¦æ™‚é–“åˆå§‹åŒ–ã€‚
            if self._stop_event.is_set(): return
            try:
                url = colab_output.eval_js(f'google.colab.kernel.proxyPort({self._port})', timeout_sec=10)
                if url and url.strip(): self._update_url_status("Colab", "ready", url=url, priority=1); return
                self._log("WARN", f"Colab ä»£ç†å˜—è©¦ #{attempt+1} è¿”å›ç©º URLã€‚", "Colab")
            except Exception as e: self._log("WARN", f"Colab ä»£ç†å˜—è©¦ #{attempt+1} å¤±æ•—: {e}", "Colab")
            time.sleep(2)
        self._update_url_status("Colab", "error", error="é‡è©¦ 10 æ¬¡å¾Œå¤±æ•—")

    def stop(self):
        """åœæ­¢æ‰€æœ‰é€šé“é€²ç¨‹ã€‚"""
        self._stop_event.set()
        for p in self._processes:
            if p.poll() is None:
                try: p.terminate()
                except ProcessLookupError: pass
        for t in self._threads: t.join(timeout=2)

# ==============================================================================
# SECTION 2: æ ¸å¿ƒåŠŸèƒ½å‡½å¼
# ==============================================================================
def create_log_viewer_html(log_manager, display_manager):
    """ ç”¢ç”Ÿæœ€çµ‚çš„ HTML æ—¥èªŒå ±å‘Šï¼ŒåŒ…å«è¤‡è£½æŒ‰éˆ•å’Œå¯æ‘ºç–Šçš„æ—¥èªŒå€åŸŸã€‚"""
    try:
        full_log_history = [f"[{log['timestamp'].isoformat()}] [{log['level']}] {log['message']}" for log in log_manager.get_full_history()]
        screen_output = "\n".join(display_manager._build_output_buffer())
        log_to_display = "\n".join(full_log_history[-LOG_COPY_MAX_LINES:])
        escaped_log_for_textarea = html.escape(log_to_display)
        escaped_screen_for_textarea = html.escape(screen_output)
        screen_id = f"screen-area-{int(time.time() * 1000)}"
        log_id = f"log-area-{int(time.time() * 1000)}"

        # ä½¿ç”¨ textarea æ–¹æ¡ˆä¾†å„²å­˜æ—¥èªŒå…§å®¹ï¼Œé€™æ˜¯æœ€ç©©å®šå¯é çš„è¤‡è£½åˆ°å‰ªè²¼ç°¿çš„æ–¹æ³•ã€‚
        return f'''
            <style>
                .collapsible-log {{ margin-top: 15px; margin-bottom: 15px; border: 1px solid #e0e0e0; padding: 12px; border-radius: 8px; background-color: #fafafa; }}
                .collapsible-log summary {{ cursor: pointer; font-weight: bold; color: #333; }}
                .collapsible-log pre {{ background-color: #fff; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 13px; color: #444; max-height: 400px; overflow-y: auto; }}
                .copy-button {{ padding: 8px 16px; margin: 5px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; font-family: sans-serif; }}
                .copy-button:hover {{ background-color: #e0e0e0; }}
            </style>
            <script>
                function copyFromTextarea(elementId, button) {{
                    const ta = document.getElementById(elementId);
                    if (!ta) {{ console.error("Textarea not found:", elementId); return; }}
                    navigator.clipboard.writeText(ta.value).then(() => {{
                        const originalText = button.innerText;
                        button.innerText = "âœ… å·²è¤‡è£½!";
                        setTimeout(() => {{ button.innerText = originalText; }}, 2000);
                    }}, (err) => {{
                        button.innerText = "âŒ è¤‡è£½å¤±æ•—";
                        console.error('è¤‡è£½å¤±æ•—: ', err);
                    }});
                }}
            </script>

            <textarea id="{screen_id}" style="position:absolute; left: -9999px; top: -9999px;" readonly>{escaped_screen_for_textarea}</textarea>
            <textarea id="{log_id}" style="position:absolute; left: -9999px; top: -9999px;" readonly>{escaped_log_for_textarea}</textarea>

            <div>
                <button class="copy-button" onclick="copyFromTextarea('{screen_id}', this)">ğŸ“‹ è¤‡è£½ä¸Šæ–¹æœ€çµ‚ç•«é¢</button>
            </div>
            <details class="collapsible-log">
                <summary>é»æ­¤å±•é–‹/æ”¶åˆæœ€è¿‘ {len(full_log_history[-LOG_COPY_MAX_LINES:])} æ¢è©³ç´°æ—¥èªŒ</summary>
                <div style="margin-top: 12px;">
                    <button class="copy-button" onclick="copyFromTextarea('{log_id}', this)">ğŸ“„ è¤‡è£½ä¸‹æ–¹å®Œæ•´æ—¥èªŒ</button>
                    <pre><code>{escaped_log_for_textarea}</code></pre>
                    <button class="copy-button" onclick="copyFromTextarea('{log_id}', this)">ğŸ“„ è¤‡è£½ä¸‹æ–¹å®Œæ•´æ—¥èªŒ</button>
                </div>
            </details>
        '''
    except Exception as e:
        return f"<p>âŒ ç”¢ç”Ÿæœ€çµ‚æ—¥èªŒå ±å‘Šæ™‚ç™¼ç”ŸéŒ¯èª¤: {html.escape(str(e))}</p>"

def archive_reports(log_manager, start_time, end_time, status):
    """å°‡æœ¬æ¬¡åŸ·è¡Œçš„æ—¥èªŒå’Œæ•ˆèƒ½å ±å‘Šå„²å­˜åˆ°æª”æ¡ˆä¸­ã€‚"""
    print("\n\n" + "="*60 + "\n--- ä»»å‹™çµæŸï¼Œé–‹å§‹åŸ·è¡Œè‡ªå‹•æ­¸æª” ---\n" + "="*60)
    try:
        root_folder = Path(LOG_ARCHIVE_ROOT_FOLDER)
        root_folder.mkdir(exist_ok=True)
        ts_folder_name = start_time.strftime('%Y-%m-%dT%H-%M-%S%z')
        report_dir = root_folder / ts_folder_name
        report_dir.mkdir(exist_ok=True)
        log_history = log_manager.get_full_history()
        detailed_log_content = f"# è©³ç´°æ—¥èªŒ\n\n```\n" + "\n".join([f"[{log['timestamp'].isoformat()}] [{log['level']}] {log['message']}" for log in log_history]) + "\n```"
        (report_dir / "è©³ç´°æ—¥èªŒ.md").write_text(detailed_log_content, encoding='utf-8')
        duration = end_time - start_time
        perf_report_content = f"# æ•ˆèƒ½å ±å‘Š\n\n- **ä»»å‹™ç‹€æ…‹**: {status}\n- **é–‹å§‹æ™‚é–“**: `{start_time.isoformat()}`\n- **çµæŸæ™‚é–“**: `{end_time.isoformat()}`\n- **ç¸½è€—æ™‚**: `{str(duration)}`\n"
        (report_dir / "æ•ˆèƒ½å ±å‘Š.md").write_text(perf_report_content.strip(), encoding='utf-8')
        (report_dir / "ç¶œåˆå ±å‘Š.md").write_text(f"# ç¶œåˆå ±å‘Š\n\n{perf_report_content}\n{detailed_log_content}", encoding='utf-8')
        print(f"âœ… å ±å‘Šå·²æˆåŠŸæ­¸æª”è‡³: {report_dir}")
    except Exception as e: print(f"âŒ æ­¸æª”å ±å‘Šæ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

# ==============================================================================
# SECTION 2.5: å®‰è£ç³»çµ±ç´šä¾è³´ (FFmpeg)
# ==============================================================================
# æŸäº›åŠŸèƒ½å¯èƒ½éœ€è¦ FFmpegï¼Œåœ¨æ­¤è™•æå‰å®‰è£ã€‚
print("æª¢æŸ¥ä¸¦å®‰è£ç³»çµ±ç´šä¾è³´ FFmpeg...")
try:
    if subprocess.run(["which", "ffmpeg"], capture_output=True).returncode != 0:
        print("æœªåµæ¸¬åˆ° FFmpegï¼Œé–‹å§‹å®‰è£...")
        # ä½¿ç”¨ -qq åƒæ•¸ä¾†æ¸›å°‘å®‰è£éç¨‹ä¸­çš„è¼¸å‡ºï¼Œä¿æŒå„€è¡¨æ¿ä¹¾æ·¨ã€‚
        subprocess.run(["apt-get", "update", "-qq"], check=True)
        subprocess.run(["apt-get", "install", "-y", "-qq", "ffmpeg"], check=True)
        print("âœ… FFmpeg å®‰è£å®Œæˆã€‚")
    else:
        print("âœ… FFmpeg å·²å®‰è£ã€‚")
except Exception as e:
    print(f"âŒ å®‰è£ FFmpeg æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

# ==============================================================================
# SECTION 3: ä¸»ç¨‹å¼åŸ·è¡Œå…¥å£
# ==============================================================================
def main():
    """ä¸»å‡½æ•¸ï¼Œå”èª¿æ‰€æœ‰ç®¡ç†å™¨å’Œæµç¨‹ã€‚"""
    start_time_monotonic = time.monotonic()
    # å»ºç«‹ä¸€å€‹å…±äº«çš„å­—å…¸ï¼Œç”¨æ–¼è·¨åŸ·è¡Œç·’å’Œç®¡ç†å™¨å‚³éç‹€æ…‹ã€‚
    shared_stats = {"start_time_monotonic": start_time_monotonic, "status": "åˆå§‹åŒ–...", "urls": {}}
    log_manager, display_manager, server_manager, tunnel_manager = None, None, None, None
    start_time = datetime.now(pytz.timezone(TIMEZONE))
    try:
        # åˆå§‹åŒ–æ‰€æœ‰ç®¡ç†å™¨
        log_levels = {name: globals()[name] for name in globals() if name.startswith("SHOW_LOG_LEVEL_")}
        log_manager = LogManager(max_lines=LOG_DISPLAY_LINES, timezone_str=TIMEZONE, log_levels_to_show=log_levels)
        server_manager = ServerManager(log_manager=log_manager, stats_dict=shared_stats)
        display_manager = DisplayManager(log_manager=log_manager, stats_dict=shared_stats, refresh_rate=UI_REFRESH_SECONDS)

        # å•Ÿå‹•å„€è¡¨æ¿å’Œä¼ºæœå™¨ç®¡ç†å™¨
        display_manager.start()
        server_manager.start()

        # ç­‰å¾…ä¼ºæœå™¨å°±ç·’ï¼Œè¨­æœ‰è¶…æ™‚æ©Ÿåˆ¶
        log_manager.log("INFO", f"è¨­å®šä¼ºæœå™¨å•Ÿå‹•è¶…æ™‚æ™‚é–“ç‚º {SERVER_READY_TIMEOUT} ç§’...")
        if server_manager.server_ready_event.wait(timeout=SERVER_READY_TIMEOUT):
            if not server_manager.port:
                log_manager.log("CRITICAL", "ä¼ºæœå™¨å·²å°±ç·’ï¼Œä½†æœªèƒ½è§£æå‡º API åŸ è™Ÿã€‚ç„¡æ³•å»ºç«‹ä»£ç†é€£çµã€‚")
            else:
                # ä¼ºæœå™¨å°±ç·’å¾Œï¼Œæ‰å•Ÿå‹•é€šé“ç®¡ç†å™¨
                log_manager.log("SUCCESS", f"âœ… å¾Œç«¯æœå‹™å·²åœ¨åŸ è™Ÿ {server_manager.port} ä¸Šå°±ç·’ï¼Œæ­£åœ¨å•Ÿå‹•æ‰€æœ‰ä»£ç†é€šé“...")
                tunnel_manager = TunnelManager(log_manager=log_manager, stats_dict=shared_stats, port=server_manager.port)
                tunnel_manager.start()
        else:
            # å¦‚æœè¶…æ™‚ï¼Œå‰‡è¨˜éŒ„åš´é‡éŒ¯èª¤ä¸¦é€€å‡ºã€‚
            shared_stats['status'] = f"âŒ ä¼ºæœå™¨å•Ÿå‹•è¶…æ™‚ ({SERVER_READY_TIMEOUT}ç§’)"
            log_manager.log("CRITICAL", f"ä¼ºæœå™¨åœ¨ {SERVER_READY_TIMEOUT} ç§’å…§æœªèƒ½å°±ç·’ã€‚å•Ÿå‹•å¤±æ•—ã€‚")
            raise SystemExit(f"Server did not start within {SERVER_READY_TIMEOUT} seconds.")

        # ç­‰å¾…ä¼ºæœå™¨åŸ·è¡Œç·’çµæŸï¼ˆé€šå¸¸æ˜¯å› ç‚ºä½¿ç”¨è€…æ‰‹å‹•åœæ­¢æˆ–ç™¼ç”ŸéŒ¯èª¤ï¼‰
        while server_manager._thread.is_alive(): time.sleep(1)

    except (KeyboardInterrupt, SystemExit) as e:
        # è™•ç†ä½¿ç”¨è€…æ‰‹å‹•ä¸­æ–· (Ctrl+C) æˆ–ç³»çµ±é€€å‡ºã€‚
        if isinstance(e, SystemExit):
            if log_manager: log_manager.log("CRITICAL", f"ç³»çµ±å› è‡´å‘½éŒ¯èª¤é€€å‡º: {e}")
        else: # KeyboardInterrupt
            if log_manager: log_manager.log("WARN", "ğŸ›‘ åµæ¸¬åˆ°ä½¿ç”¨è€…æ‰‹å‹•ä¸­æ–·...")
    except Exception as e:
        if log_manager: log_manager.log("CRITICAL", f"âŒ ç™¼ç”Ÿæœªé æœŸçš„è‡´å‘½éŒ¯èª¤: {e}")
        else: print(f"âŒ ç™¼ç”Ÿæœªé æœŸçš„è‡´å‘½éŒ¯èª¤: {e}")
    finally:
        # æ¸…ç†ç¨‹åºï¼šç„¡è«–æˆåŠŸæˆ–å¤±æ•—ï¼Œéƒ½ç¢ºä¿æ‰€æœ‰èƒŒæ™¯åŸ·è¡Œç·’å’Œå­é€²ç¨‹éƒ½è¢«å®‰å…¨é—œé–‰ã€‚
        if display_manager and display_manager._thread.is_alive(): display_manager.stop()
        if 'tunnel_manager' in locals() and tunnel_manager: tunnel_manager.stop()
        if server_manager: server_manager.stop()
        end_time = datetime.now(pytz.timezone(TIMEZONE))

        # åœ¨æœ€å¾Œé¡¯ç¤ºæœ€çµ‚çš„å ±å‘Šå’Œæ—¥èªŒã€‚
        if log_manager and display_manager:
            clear_output(); print("\n".join(display_manager._build_output_buffer()))
            print("\n--- âœ… æ‰€æœ‰ä»»å‹™å®Œæˆï¼Œç³»çµ±å·²å®‰å…¨é—œé–‰ ---")
            display(HTML(create_log_viewer_html(log_manager, display_manager)))
            archive_reports(log_manager, start_time, end_time, shared_stats.get('status', 'æœªçŸ¥'))

if __name__ == "__main__":
    main()
