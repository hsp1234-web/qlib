

# -*- coding: utf-8 -*-
# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                                                                      â•‘
# â•‘   âœ¨ğŸº å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ (v50) ğŸº                                   âœ¨ğŸº â•‘
# â•‘                                                                      â•‘
# â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
# â•‘                                                                      â•‘
# â•‘ - V48 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **åŠŸèƒ½**: æ–°å¢æ—¥èªŒå¤šè¡Œé¡¯ç¤ºåŠŸèƒ½ï¼Œå„ªåŒ–è¡Œå‹•è£ç½®å¯è®€æ€§ã€‚             â•‘
# â•‘   - **ä¿®å¾©**: æ”¹ç”¨å‘½ä»¤åˆ—åƒæ•¸å‚³é FRED é‡‘é‘°ï¼Œå¾¹åº•è§£æ±ºæ³¨å…¥å¤±æ•—å•é¡Œã€‚   â•‘
# â•‘ - V47 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **ä¿®å¾©**: ä¿®æ­£ FRED é‡‘é‘°æœªè¢«æ³¨å…¥è³‡æ–™åº«å°è‡´å‰ç«¯ç„¡æ³•é¡¯ç¤ºçš„å•é¡Œã€‚   â•‘
# â•‘   - **ä¿®å¾©**: èª¿æ•´å•Ÿå‹•æ™‚åºï¼Œè§£æ±ºå› ç«¶çˆ­æ¢ä»¶å°è‡´çš„é¦–æ¬¡é‡‘é‘°è‡ªå‹•é©—è­‰å¤±æ•— â•‘
# â•‘     å•é¡Œã€‚                                                         â•‘
# â•‘   - **èª¿æ•´**: å°‡é è¨­åˆ†æ”¯æ›´æ–°è‡³ `91`ã€‚                                â•‘
# â•‘ - V46 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **é‡æ§‹**: èª¿æ•´å•Ÿå‹•æ™‚åºï¼Œä¿®å¾©å› ç«¶çˆ­æ¢ä»¶å°è‡´çš„é‡‘é‘°è¼‰å…¥èˆ‡é©—è­‰å¤±æ•—   â•‘
# â•‘     å•é¡Œï¼Œå¤§å¹…æå‡å•Ÿå‹•ç©©å®šæ€§ã€‚                                     â•‘
# â•‘ - V45 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **ä¿®å¾©**: ä¿®æ­£ `colabPro.py` åŸ·è¡Œç•°å¸¸å•é¡Œã€‚                      â•‘
# â•‘   - **èª¿æ•´**: æ›´æ–°é è¨­åˆ†æ”¯è™Ÿç¢¼ç‚º `90.1`ï¼Œä¸¦åŒæ­¥ç‰ˆæœ¬è™Ÿè‡³ `v45`ã€‚      â•‘
# â•‘ - V39 æ›´æ–°æ—¥èªŒ (2025-09-30):                                         â•‘
# â•‘   - **æˆ°ç•¥ä¿®æ­£**: æ¡ç”¨æœ€å°åŒ–ä¿®æ”¹ç­–ç•¥ï¼Œç‚º FRED é‡‘é‘°æ–°å¢å‰ç«¯ç‹€æ…‹æ¢æ¸¬   â•‘
# â•‘     æ¥å£ï¼Œä»¥ç¢ºä¿ç³»çµ±ç©©å®šæ€§ã€‚                                       â•‘
# â•‘ - V32 æ›´æ–°æ—¥èªŒ (2025-09-27):                                         â•‘
# â•‘   - **æ–°å¢åŠŸèƒ½**: è‡ªå‹•åµæ¸¬ä¸¦é¡¯ç¤º `localtunnel` çš„é€šé“å¯†ç¢¼ï¼Œç„¡éœ€     â•‘
# â•‘     ä½¿ç”¨è€…æ‰‹å‹•æŸ¥è©¢ã€‚                                               â•‘
# â•‘ - V28.1 æ›´æ–°æ—¥èªŒ (2025-09-16):                                       â•‘
# â•‘   - **å¢å¼·æ—¥èªŒ**: ç‚ºé‡‘é‘°è‡ªå‹•é©—è­‰æµç¨‹æ·»åŠ æ›´è©³ç´°çš„æ—¥èªŒè¨˜éŒ„ï¼Œä»¥ä¾¿è¿½è¹¤   â•‘
# â•‘     åŸ·è¡Œç‹€æ…‹ä¸¦è¨ºæ–·æ½›åœ¨å•é¡Œã€‚                                       â•‘
# â•‘ - V28 æ›´æ–°æ—¥èªŒ (2025-09-16):                                         â•‘
# â•‘   - **ä¿®å¾©é‡‘é‘°é©—è­‰**: èª¿æ•´é‡‘é‘°é©—è­‰æ™‚çš„å­ç¨‹åºç’°å¢ƒï¼Œè§£æ±ºé«˜éšç¡¬é«”ä¸Š     â•‘
# â•‘     å› ç’°å¢ƒè®Šæ•¸ä¸å®Œæ•´è€Œå°è‡´çš„é©—è­‰å¤±æ•—å•é¡Œã€‚                         â•‘
# â•‘   - **æ›´æ–°é è¨­åˆ†æ”¯**: å°‡é è¨­åˆ†æ”¯è™Ÿç¢¼æ›´æ–°ç‚º `25.4`ã€‚                  â•‘
# â•‘                                                                      â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#@title âœ¨ğŸº å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ (v50)  ğŸº { vertical-output: true, display-mode: "form" }
#@markdown ---
#@markdown ### **æ ¸å¿ƒè¨­å®š**
#@markdown > **è«‹ç¢ºèªä»¥ä¸‹å…©å€‹æ ¸å¿ƒè¨­å®šã€‚**
#@markdown ---
#@markdown **å¾Œç«¯ç‰ˆæœ¬åˆ†æ”¯æˆ–æ¨™ç±¤**
TARGET_BRANCH_OR_TAG = "141.2" #@param {type:"string"}
#@markdown **è‡ªå‹•å¾ Colab Secrets è¼‰å…¥çš„é‡‘é‘°æ•¸é‡ (0-20)**
#@markdown > è¼¸å…¥ `2` å°‡è¼‰å…¥ `GOOGLE_API_KEY`, `_1`, `_2` å…±ä¸‰çµ„é‡‘é‘°ã€‚
KEY_LOAD_COUNT_LIMIT = 2 #@param {type:"number"}
#@markdown **æ—¥èªŒé¡¯ç¤ºè¡Œæ•¸ (1-15)**
#@markdown > è¨­å®šå–®æ¢æ—¥èªŒåœ¨å„€è¡¨æ¿ä¸­ä½”æ“šçš„ç¸½è¡Œæ•¸ã€‚`1` ç‚ºå–®è¡Œç·Šæ¹Šæ¨¡å¼ï¼Œ`2-15` ç‚ºå¤šè¡Œæ¨¡å¼ã€‚
LOG_SPLIT_LINES = 2 #@param {type:"number"}
#@markdown ---
#@markdown > **è¨­å®šå®Œæˆå¾Œï¼Œé»æ“Šã€ŒåŸ·è¡Œã€æŒ‰éˆ•ã€‚**
#@markdown ---

# --- JULES'S NEW FEATURE (2025-09-30): åƒæ•¸é‚Šç•Œé©—è­‰ ---
if not 1 <= LOG_SPLIT_LINES <= 15:
    print(f"âš ï¸ è­¦å‘Šï¼šæ—¥èªŒé¡¯ç¤ºè¡Œæ•¸è¨­å®šå€¼ ({LOG_SPLIT_LINES}) è¶…å‡ºæœ‰æ•ˆç¯„åœ (1-15)ã€‚å°‡è‡ªå‹•ä½¿ç”¨é è¨­å€¼ 2ã€‚")
    LOG_SPLIT_LINES = 2

# ==============================================================================
# SECTION A: é€²éšè¨­å®š (å¯åœ¨æ­¤è™•ä¿®æ”¹)
# èªªæ˜ï¼šä»¥ä¸‹ç‚ºä¸å¸¸è®Šå‹•çš„é€²éšè¨­å®šã€‚è‹¥éœ€èª¿æ•´ï¼Œè«‹ç›´æ¥ä¿®æ”¹æ­¤å€å¡Šçš„è®Šæ•¸å€¼ã€‚
# ==============================================================================

# Part 1: æ ¸å¿ƒå°ˆæ¡ˆè¨­å®š (å›ºå®š)
REPOSITORY_URL = "https://github.com/hsp1234-web/20250910.git"
PROJECT_FOLDER_NAME = "wolf_project"
FORCE_REPO_REFRESH = True

# Part 1.5: é€šé“å•Ÿç”¨è¨­å®š
ENABLE_COLAB_PROXY = True
ENABLE_LOCALTUNNEL = True
ENABLE_CLOUDFLARE = True

# Part 2: å„€è¡¨æ¿èˆ‡ç›£æ§è¨­å®š
UI_REFRESH_SECONDS = 0.5
LOG_DISPLAY_LINES = 5
TIMEZONE = "Asia/Taipei"

# Part 3: æ—¥èªŒç­‰ç´šå¯è¦‹æ€§
SHOW_LOG_LEVEL_BATTLE = True
SHOW_LOG_LEVEL_SUCCESS = True
SHOW_LOG_LEVEL_INFO = True
SHOW_LOG_LEVEL_WARN = True
SHOW_LOG_LEVEL_ERROR = True
SHOW_LOG_LEVEL_CRITICAL = True
SHOW_LOG_LEVEL_DEBUG = True

# Part 4: å ±å‘Šèˆ‡æ­¸æª”è¨­å®š
LOG_ARCHIVE_ROOT_FOLDER = "paper"
SERVER_READY_TIMEOUT = 150
LOG_COPY_MAX_LINES = 5000

# ==============================================================================
# SECTION 0: ç’°å¢ƒæº–å‚™èˆ‡æ ¸å¿ƒä¾è³´å°å…¥ (æ­¤è™•é–‹å§‹ç‚ºæ ¸å¿ƒç¨‹å¼ï¼Œé€šå¸¸ç„¡éœ€ä¿®æ”¹)
# ==============================================================================
import sys
import subprocess
import socket
import platform
import urllib.request
try:
    import pytz
except ImportError:
    print("æ­£åœ¨å®‰è£ pytz...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "pytz"])
    import pytz

import os
import shutil
from pathlib import Path
import time
from datetime import datetime
import threading
from collections import deque
import re
import json
import html
import requests
from IPython.display import clear_output, display, HTML
from google.colab import output as colab_output

# ==============================================================================
# SECTION 1: ç®¡ç†å™¨é¡åˆ¥å®šç¾© (Managers)
# ==============================================================================

class LogManager:
    """æ—¥èªŒç®¡ç†å™¨ï¼šè² è²¬è¨˜éŒ„ã€éæ¿¾å’Œå„²å­˜æ‰€æœ‰æ—¥èªŒè¨Šæ¯ã€‚"""
    def __init__(self, max_lines, timezone_str, log_levels_to_show):
        self._log_deque = deque(maxlen=max_lines)
        self._full_history = []
        self._lock = threading.Lock()
        self.timezone = pytz.timezone(timezone_str)
        self.log_levels_to_show = log_levels_to_show

    def log(self, level: str, message: str, source: str = "SYSTEM"):
        with self._lock:
            log_entry = {"timestamp": datetime.now(self.timezone), "level": level.upper(), "message": str(message), "source": source}
            self._log_deque.append(log_entry)
            self._full_history.append(log_entry)

    def get_display_logs(self) -> list:
        with self._lock:
            all_logs = list(self._log_deque)
            return [log for log in all_logs if self.log_levels_to_show.get(f"SHOW_LOG_LEVEL_{log['level']}", False)]

    def get_full_history(self) -> list:
        with self._lock:
            return self._full_history

ANSI_COLORS = {
    "SUCCESS": "\033[32m", "WARN": "\033[33m", "ERROR": "\033[31m",
    "CRITICAL": "\033[31m", "RESET": "\033[0m"
}

def colorize(text, level):
    return f"{ANSI_COLORS.get(level, '')}{text}{ANSI_COLORS['RESET']}"

class DisplayManager:
    """é¡¯ç¤ºç®¡ç†å™¨ï¼šåœ¨èƒŒæ™¯åŸ·è¡Œç·’ä¸­è² è²¬ç¹ªè£½ç´”æ–‡å­—å‹•æ…‹å„€è¡¨æ¿ã€‚"""
    def __init__(self, log_manager, stats_dict, refresh_rate):
        self._log_manager = log_manager
        self._stats = stats_dict
        self._refresh_rate = refresh_rate
        self._stop_event = threading.Event()
        self._thread = threading.Thread(target=self._run, daemon=True)

    def _build_output_buffer(self) -> list[str]:
        output_buffer = ["âœ¨ğŸº å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ (v50) ğŸº", ""]
        logs_to_display = self._log_manager.get_display_logs()

        # JULES'S NEW FEATURE (2025-09-30): æ—¥èªŒæ ¼å¼åŒ–é‚è¼¯
        for log in logs_to_display:
            ts = log['timestamp'].strftime('%H:%M:%S')
            level, msg = log['level'], log['message']

            if LOG_SPLIT_LINES == 1:
                # --- å–®è¡Œç·Šæ¹Šæ¨¡å¼ ---
                output_buffer.append(f"[{ts}] {colorize(f'[{level:^8}]', level)} {msg}")
            else:
                # --- å¤šè¡Œèˆ’é©æ¨¡å¼ ---
                # ç¬¬ä¸€è¡Œï¼šæ°¸é æ˜¯æ™‚é–“æˆ³å’Œæ—¥èªŒç­‰ç´š
                header = f"[{ts}] {colorize(f'[{level:^8}]', level)}"
                output_buffer.append(header)

                # å¾ŒçºŒè¡Œï¼šè™•ç†è¨Šæ¯æœ¬æ–‡
                num_message_lines = max(1, LOG_SPLIT_LINES - 1)

                if not msg: # å¦‚æœè¨Šæ¯ç‚ºç©ºï¼Œå‰‡ä¸æ·»åŠ é¡å¤–è¡Œ
                    continue

                # è¨ˆç®—æ¯è¡Œæ‡‰é¡¯ç¤ºçš„å¹³å‡å­—å…ƒæ•¸
                avg_len = len(msg) / num_message_lines

                start_index = 0
                for i in range(num_message_lines):
                    if start_index >= len(msg):
                        break

                    # å°æ–¼æœ€å¾Œä¸€è¡Œï¼Œç›´æ¥å–åˆ°çµå°¾
                    end_index = len(msg) if i == num_message_lines - 1 else int(start_index + avg_len + 0.5)

                    line_content = msg[start_index:end_index].strip()
                    if line_content:
                        output_buffer.append(line_content)

                    start_index = end_index

        urls = self._stats.get('urls', {})
        if urls:
            if logs_to_display: output_buffer.append("")
            output_buffer.append("ğŸ”— å…¬é–‹å­˜å–ç¶²å€ (Public URLs):")
            sorted_urls = sorted(urls.items(), key=lambda item: item[1].get('priority', 99))
            for name, url_info in sorted_urls:
                if url_info['status'] == 'ready':
                    line = f"  - {name}: {colorize(url_info['url'], 'SUCCESS')}"
                    if 'password' in url_info:
                        line += f" (å¯†ç¢¼: {url_info['password']})"
                    output_buffer.append(line)
                elif url_info['status'] == 'starting':
                    output_buffer.append(f"  - {name}: æ­£åœ¨å•Ÿå‹•ä¸­...")
                else:
                    output_buffer.append(f"  - {name}: {colorize(url_info.get('error', 'ç™¼ç”ŸéŒ¯èª¤'), 'ERROR')}")

        try:
            import psutil
            cpu, ram = f"{psutil.cpu_percent():5.1f}%", f"{psutil.virtual_memory().percent:5.1f}%"
        except ImportError:
            cpu, ram = "  N/A ", "  N/A "
        elapsed = time.monotonic() - self._stats.get("start_time_monotonic", time.monotonic())
        mins, secs = divmod(elapsed, 60)
        output_buffer.append("")
        output_buffer.append(f"â±ï¸ {int(mins):02d}åˆ†{int(secs):02d}ç§’ | ğŸ’» CPU: {cpu} | ğŸ§  RAM: {ram} | ğŸ”¥ ç‹€æ…‹: {self._stats.get('status', 'åˆå§‹åŒ–...')}")
        return output_buffer

    def _run(self):
        while not self._stop_event.is_set():
            try:
                clear_output(wait=True)
                print("\n".join(self._build_output_buffer()), flush=True)
                time.sleep(self._refresh_rate)
            except Exception as e:
                self._log_manager.log("ERROR", f"DisplayManager åŸ·è¡Œç·’ç™¼ç”ŸéŒ¯èª¤: {e}")
                time.sleep(5)

    def start(self): self._thread.start()
    def stop(self): self._stop_event.set(); self._thread.join(timeout=2)

class ServerManager:
    """ä¼ºæœå™¨ç®¡ç†å™¨ï¼šè² è²¬å•Ÿå‹•ã€åœæ­¢å’Œç›£æ§ Uvicorn å­é€²ç¨‹ã€‚"""
    def __init__(self, log_manager, stats_dict):
        self._log_manager = log_manager; self._stats = stats_dict
        self.server_process = None; self.server_ready_event = threading.Event()
        self._stop_event = threading.Event()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self.port = None

    def _ensure_uv_installed(self):
        """æª¢æŸ¥ `uv` æ˜¯å¦å·²å®‰è£ï¼Œè‹¥å¦ï¼Œå‰‡å˜—è©¦å®‰è£ã€‚"""
        try:
            subprocess.check_call([sys.executable, "-m", "uv", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self._log_manager.log("INFO", "âœ… 'uv' åŠ é€Ÿå™¨å·²å®‰è£ã€‚")
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            self._log_manager.log("INFO", "æœªæ‰¾åˆ° 'uv'ï¼Œæ­£åœ¨å˜—è©¦å®‰è£...")
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "uv"])
                self._log_manager.log("SUCCESS", "âœ… 'uv' åŠ é€Ÿå™¨å®‰è£æˆåŠŸï¼")
                return True
            except subprocess.CalledProcessError:
                self._log_manager.log("WARN", "å®‰è£ 'uv' å¤±æ•—ï¼Œå°‡é€€å›ä½¿ç”¨ 'pip'ã€‚")
                return False

    def _inject_keys_background(self, project_path: Path):
        """
        [èƒŒæ™¯åŸ·è¡Œ] è² è²¬å¾ Colab Secrets ç²å–é‡‘é‘°ä¸¦é€éè…³æœ¬æ³¨å…¥ã€‚
        """
        self._log_manager.log("INFO", "[èƒŒæ™¯] é–‹å§‹åŸ·è¡Œé‡‘é‘°æ³¨å…¥...")
        try:
            # --- (ä¸­æ–‡è¨»è§£) æ ¸å¿ƒé‡‘é‘°æ³¨å…¥é‚è¼¯ï¼ˆv2 ä¿®æ­£ç‰ˆï¼‰ ---
            # æ ¹æœ¬åŸå› ï¼šåœ¨å­ç¨‹åºä¸­å‘¼å« google.colab.userdata.get() æœƒå› ç¼ºå°‘å‰ç«¯ä¸Šä¸‹æ–‡è€Œå¤±æ•—ã€‚
            # è§£æ±ºæ–¹æ¡ˆï¼šåœ¨æ“æœ‰å®Œæ•´ä¸Šä¸‹æ–‡çš„ä¸»ç¨‹åºä¸­ç²å–æ‰€æœ‰é‡‘é‘°ï¼Œ
            # ç„¶å¾Œå°‡é‡‘é‘°å…§å®¹é€é `--mode manual` å®‰å…¨åœ°å‚³éçµ¦å­ç¨‹åºã€‚
            key_injector_script = project_path / "scripts" / "colab_key_injector.py"
            if not key_injector_script.is_file():
                self._log_manager.log("WARN", f"[èƒŒæ™¯] æœªæ‰¾åˆ°é‡‘é‘°æ³¨å…¥è…³æœ¬ '{key_injector_script}'ï¼Œè·³éé‡‘é‘°è¼‰å…¥ã€‚")
                return

            from google.colab import userdata
            self._log_manager.log("INFO", "[èƒŒæ™¯] æ­£åœ¨å¾ Colab Secrets ç²å–é‡‘é‘°...")

            base_key_name = "GOOGLE_API_KEY"
            target_key_names = [base_key_name]
            if KEY_LOAD_COUNT_LIMIT > 0:
                target_key_names.extend([f"{base_key_name}_{i}" for i in range(1, KEY_LOAD_COUNT_LIMIT + 1)])

            keys_to_inject = []
            for key_name in target_key_names:
                try:
                    key_value = userdata.get(key_name)
                    if key_value and key_value.strip():
                        keys_to_inject.append(key_value)
                        self._log_manager.log("INFO", f"[èƒŒæ™¯] âœ… å·²æˆåŠŸç²å–é‡‘é‘° '{key_name}'ã€‚")
                except userdata.SecretNotFoundError:
                    self._log_manager.log("INFO", f"[èƒŒæ™¯] ğŸŸ¡ æœªåœ¨ Colab Secrets ä¸­æ‰¾åˆ°é‡‘é‘° '{key_name}'ï¼Œè·³éã€‚")
                except Exception as e:
                    # æ•æ‰å…¶ä»–å¯èƒ½çš„éŒ¯èª¤ï¼Œä¾‹å¦‚æ¬Šé™å•é¡Œ
                    self._log_manager.log("WARN", f"[èƒŒæ™¯] è®€å–é‡‘é‘° '{key_name}' æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}ï¼Œè·³éã€‚")

            if not keys_to_inject:
                 self._log_manager.log("WARN", "[èƒŒæ™¯] æœªå¾ Colab Secrets ä¸­ç²å–åˆ°ä»»ä½•é‡‘é‘°ï¼Œè·³éæ³¨å…¥ã€‚")
                 return

            keys_string = "\n".join(keys_to_inject)
            command = [
                sys.executable, str(key_injector_script.resolve()),
                "--mode", "manual", "--manual-keys", keys_string
            ]

            # --- JULES'S FIX V3 (2025-09-30): æ”¹ç”¨å‘½ä»¤åˆ—åƒæ•¸å‚³é FRED é‡‘é‘° ---
            # é€™æ˜¯æœ€ç©©å¥å¯é çš„æ–¹å¼ï¼Œå¾¹åº•é¿å…ç’°å¢ƒè®Šæ•¸ç¹¼æ‰¿å•é¡Œã€‚
            fred_api_key = None
            try:
                fred_api_key = userdata.get('FRED_API_KEY')
                if fred_api_key and fred_api_key.strip():
                    # å¦‚æœæ‰¾åˆ°äº† FRED é‡‘é‘°ï¼Œå°±å°‡å…¶é™„åŠ åˆ°å‘½ä»¤åˆ—åƒæ•¸ä¸­
                    command.extend(["--fred-key", fred_api_key])
                    self._log_manager.log("INFO", "[èƒŒæ™¯] æˆåŠŸè®€å– FRED_API_KEY ä¸¦æº–å‚™é€éåƒæ•¸å‚³éã€‚", "KeyInjector")
            except Exception:
                self._log_manager.log("WARN", "[èƒŒæ™¯] æœªèƒ½åœ¨ Colab Secrets ä¸­æ‰¾åˆ° FRED_API_KEYã€‚", "KeyInjector")

            # ä½¿ç”¨ Popen ä»¥éé˜»å¡æ–¹å¼åŸ·è¡Œï¼Œä¸¦é€é stream_reader è™•ç†æ—¥èªŒ
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
            for line in iter(process.stdout.readline, ''):
                self._log_manager.log("INFO", f"[èƒŒæ™¯] {line.strip()}", "KeyInjector")
            process.wait()

            if process.returncode == 0:
                self._log_manager.log("SUCCESS", "[èƒŒæ™¯] âœ… é‡‘é‘°æ³¨å…¥è…³æœ¬åŸ·è¡Œå®Œç•¢ã€‚")
            else:
                self._log_manager.log("WARN", f"[èƒŒæ™¯] é‡‘é‘°æ³¨å…¥è…³æœ¬åŸ·è¡ŒçµæŸï¼Œä½†è¿”å›ç¢¼ç‚º {process.returncode}ã€‚")

        except ImportError:
            self._log_manager.log("WARN", "[èƒŒæ™¯] ç„¡æ³•åŒ¯å…¥ google.colab.userdataï¼Œå¯èƒ½ä¸¦éåœ¨ Colab ç’°å¢ƒã€‚è·³éé‡‘é‘°æ³¨å…¥ã€‚")
        except Exception as e:
            self._log_manager.log("ERROR", f"[èƒŒæ™¯] åŸ·è¡Œé‡‘é‘°æ³¨å…¥æ™‚ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤: {e}")
        finally:
            self._log_manager.log("INFO", "[èƒŒæ™¯] é‡‘é‘°æ³¨å…¥åŸ·è¡Œç·’çµæŸã€‚")


    def _run(self):
        try:
            self._log_manager.log("BATTLE", "=== å•Ÿå‹•å™¨æ ¸å¿ƒæµç¨‹é–‹å§‹ ===")
            self._stats['status'] = "ğŸš€ æº–å‚™åŸ·è¡Œç’°å¢ƒ..."
            project_path = Path(PROJECT_FOLDER_NAME)
            if FORCE_REPO_REFRESH and project_path.exists():
                self._log_manager.log("INFO", f"åµæ¸¬åˆ°èˆŠçš„å°ˆæ¡ˆè³‡æ–™å¤¾ '{project_path}'ï¼Œæ­£åœ¨å¼·åˆ¶åˆªé™¤...")
                shutil.rmtree(project_path)

            self._log_manager.log("INFO", f"æ­£åœ¨å¾ Git ä¸‹è¼‰ (åˆ†æ”¯: {TARGET_BRANCH_OR_TAG})...")
            git_command = ["git", "clone", "--branch", TARGET_BRANCH_OR_TAG, "--depth", "1", REPOSITORY_URL, str(project_path)]
            result = subprocess.run(git_command, check=False, capture_output=True, text=True, encoding='utf-8')
            if result.returncode != 0:
                error_message = f"""Git clone å¤±æ•—! è¿”å›ç¢¼: {result.returncode}
--- STDOUT ---
{result.stdout}
--- STDERR ---
{result.stderr}
"""
                self._log_manager.log("CRITICAL", error_message)
                return

            self._log_manager.log("INFO", "âœ… Git å€‰åº«ä¸‹è¼‰å®Œæˆã€‚")
            self._log_manager.log("INFO", f"--- Git Clone å®Œæˆ (è€—æ™‚: {time.monotonic() - self._stats.get('start_time_monotonic', 0):.2f} ç§’) ---")
            project_src_path = project_path / "src"
            project_src_path_str = str(project_src_path.resolve())
            if project_src_path_str not in sys.path:
                sys.path.insert(0, project_src_path_str)

            # --- JULES (2025-09-30): é‡æ§‹å•Ÿå‹•æµç¨‹ï¼Œå°‡è³‡æ–™åº«åˆå§‹åŒ–æå‡è‡³æœ€é«˜å„ªå…ˆç´š ---
            self._log_manager.log("INFO", "ğŸ”© æ­¥é©Ÿ 1/5: æ­£åœ¨åˆå§‹åŒ–è³‡æ–™åº«çµæ§‹...")
            try:
                # å‹•æ…‹åŒ¯å…¥æœ€æ–°çš„é‡‘é‘°è³‡æ–™åº«åˆå§‹åŒ–æ¨¡çµ„
                from db import initialize_database as key_db_init
                # ä½¿ç”¨ä¸€å€‹å‡çš„ stream ä¾†æ•ç²å…¶ print è¼¸å‡º, ä»¥ä¾¿æ•´åˆåˆ°ä¸»æ—¥èªŒ
                from io import StringIO
                import contextlib

                init_log_stream = StringIO()
                with contextlib.redirect_stdout(init_log_stream):
                    key_db_init.initialize()

                init_logs = init_log_stream.getvalue().strip()
                if init_logs:
                    for line in init_logs.split('\n'):
                        # å°‡å­è…³æœ¬çš„æ—¥èªŒè½‰ç™¼åˆ°ä¸»æ—¥èªŒç®¡ç†å™¨
                        self._log_manager.log("INFO", f"[DB_Init] {line}", "Database")
                self._log_manager.log("SUCCESS", "âœ… é‡‘é‘°è³‡æ–™åº«çµæ§‹å·²æ˜¯æœ€æ–°ç‰ˆæœ¬ã€‚")

                # ä¿ç•™èˆŠçš„ä»»å‹™è³‡æ–™åº«åˆå§‹åŒ–æµç¨‹ (å¦‚æœä»ç„¶éœ€è¦)
                from db.database import initialize_database as task_db_init, add_system_log
                task_db_init()
                add_system_log("colab_setup", "INFO", "Git repository cloned and DB schema updated.")
                self._log_manager.log("INFO", "âœ… èˆŠç‰ˆä»»å‹™è³‡æ–™åº«åˆå§‹åŒ–æˆåŠŸã€‚")

            except Exception as e:
                self._log_manager.log("CRITICAL", f"è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—ï¼Œé€™æ˜¯ä¸€å€‹è‡´å‘½éŒ¯èª¤ï¼Œå•Ÿå‹•ä¸­æ­¢ã€‚ {e}", "Database")
                # çµ‚æ­¢åŸ·è¡Œç·’
                return

            # --- JULES: é‡æ§‹ç‚ºå…©éšæ®µä¾è³´å®‰è£ (Pip å„ªå…ˆ) ---
            def install_requirements(req_files, log_prefix="", force_pip=False):
                """
                å¹«åŠ©å‡½å¼ï¼šæ™ºæ…§åœ°æª¢æŸ¥ä¸¦åªå®‰è£ç¼ºå¤±çš„ä¾è³´ã€‚
                æ–°å¢ force_pip é¸é …ä»¥å¼·åˆ¶ä½¿ç”¨ pipã€‚
                """
                self._log_manager.log("INFO", f"[{log_prefix}] é–‹å§‹æª¢æŸ¥èˆ‡å®‰è£ä¾è³´...")
                install_start_time = time.monotonic()

                checker_script = project_path / "scripts" / "check_deps.py"
                if not checker_script.is_file():
                    self._log_manager.log("CRITICAL", f"[{log_prefix}] ä¾è³´æª¢æŸ¥è…³æœ¬ 'check_deps.py' ä¸å­˜åœ¨ï¼")
                    raise FileNotFoundError("Dependency checker script not found.")

                req_file_paths = [str(p.resolve()) for p in req_files if p.is_file()]
                if not req_file_paths:
                    self._log_manager.log("INFO", f"[{log_prefix}] æ‰¾ä¸åˆ°ä»»ä½•æœ‰æ•ˆçš„ä¾è³´æª”æ¡ˆã€‚")
                    return

                check_command = [sys.executable, str(checker_script.resolve())] + req_file_paths
                result = subprocess.run(check_command, capture_output=True, text=True, encoding='utf-8')

                missing_packages = result.stdout.strip().splitlines() if result.returncode == 0 else \
                                   "".join([p.read_text(encoding='utf-8') for p in req_files]).strip().splitlines()

                if not missing_packages:
                    self._log_manager.log("SUCCESS", f"âœ… [{log_prefix}] æ‰€æœ‰ä¾è³´å‡å·²æ»¿è¶³ï¼Œç„¡éœ€å®‰è£ã€‚")
                    return

                self._log_manager.log("INFO", f"[{log_prefix}] åµæ¸¬åˆ° {len(missing_packages)} å€‹ç¼ºå¤±çš„å¥—ä»¶ï¼Œé–‹å§‹å®‰è£...")

                temp_req_path = project_path / f"requirements_missing_{log_prefix.lower().replace(' ', '_')}.txt"
                with open(temp_req_path, "w", encoding="utf-8") as f:
                    f.write("\n".join(missing_packages))

                try:
                    # æ ¹æ“š force_pip æ±ºå®šæ˜¯å¦å˜—è©¦ä½¿ç”¨ uv
                    use_uv = not force_pip and Path("./uv").is_file()
                    if use_uv:
                        # ç§»é™¤ -q åƒæ•¸ä»¥ç²å–è©³ç´°æ—¥èªŒ
                        pip_command = [sys.executable, "-m", "uv", "pip", "install", "--system", "-r", str(temp_req_path)]
                        self._log_manager.log("INFO", f"[{log_prefix}] ä½¿ç”¨ 'uv' é€²è¡Œå¿«é€Ÿå®‰è£...")
                    else:
                        # ç§»é™¤ -q å’Œ --progress-bar off åƒæ•¸ä»¥ç²å–è©³ç´°æ—¥èªŒ
                        pip_command = [sys.executable, "-m", "pip", "install", "-r", str(temp_req_path)]
                        self._log_manager.log("INFO", f"[{log_prefix}] ä½¿ç”¨ 'pip' é€²è¡Œå®‰è£ã€‚")

                    # æ”¹ç”¨ subprocess.run ä»¥ä¾¿æ•ç²éŒ¯èª¤è¼¸å‡º
                    result = subprocess.run(pip_command, capture_output=True, text=True, encoding='utf-8')

                    # ç„¡è«–æˆåŠŸæˆ–å¤±æ•—ï¼Œéƒ½è¨˜éŒ„ stdout
                    if result.stdout and result.stdout.strip():
                        self._log_manager.log("DEBUG", f"[{log_prefix}] pip stdout:\n{result.stdout}", "Installer")

                    if result.returncode != 0:
                        # å¦‚æœå®‰è£å¤±æ•—ï¼Œè¨˜éŒ„è©³ç´°çš„éŒ¯èª¤æ—¥èªŒ
                        error_log = f"pip install å¤±æ•—ï¼è¿”å›ç¢¼: {result.returncode}\n"
                        if result.stderr and result.stderr.strip():
                            error_log += f"STDERR:\n{result.stderr}\n"
                        self._log_manager.log("ERROR", error_log, "Installer")
                        # é‡æ–°å¼•ç™¼ç•°å¸¸ï¼Œè®“ä¸Šå±¤çŸ¥é“å®‰è£å¤±æ•—äº†
                        raise subprocess.CalledProcessError(result.returncode, pip_command, output=result.stdout, stderr=result.stderr)

                    self._log_manager.log("SUCCESS", f"âœ… [{log_prefix}] ä¾è³´å®‰è£å®Œæˆã€‚")
                    self._log_manager.log("INFO", f"--- [{log_prefix}] å®‰è£è€—æ™‚: {time.monotonic() - install_start_time:.2f} ç§’ ---")
                except subprocess.CalledProcessError as e:
                    self._log_manager.log("CRITICAL", f"[{log_prefix}] ä¾è³´å®‰è£å¤±æ•—ï¼", "Installer")
                    raise
                finally:
                    if temp_req_path.exists():
                        temp_req_path.unlink()

            # --- JULES'S FIX (2025-09-21): å¼·åˆ¶å®‰è£ä¸‹è¼‰å™¨ä¾è³´ ---
            # ç‚ºäº†ç¹éåœ¨æŸäº› Colab ç’°å¢ƒä¸­ä¸ç©©å®šçš„ä¾è³´æª¢æŸ¥ï¼Œæˆ‘å€‘ç‚ºä¸‹è¼‰å™¨å»ºç«‹äº†ä¸€å€‹
            # ç¨ç«‹çš„å®‰è£éšæ®µã€‚æ­¤éšæ®µä¸ä½¿ç”¨ check_deps.pyï¼Œè€Œæ˜¯ç›´æ¥å¼·åˆ¶å®‰è£ï¼Œ
            # ç¢ºä¿ yt-dlp å’Œ gdown ç­‰é—œéµå¥—ä»¶ä¸€å®šå­˜åœ¨ã€‚
            def force_install_packages(req_file: Path, log_prefix: str):
                """ä¸€å€‹ç°¡åŒ–çš„å®‰è£å‡½å¼ï¼Œä¸æª¢æŸ¥ï¼Œç›´æ¥å®‰è£ã€‚å„ªå…ˆä½¿ç”¨ uv åŠ é€Ÿå™¨ã€‚"""
                if not req_file.is_file():
                    self._log_manager.log("WARN", f"[{log_prefix}] ä¾è³´æª”æ¡ˆ '{req_file.name}' ä¸å­˜åœ¨ï¼Œè·³éã€‚")
                    return
                self._log_manager.log("INFO", f"[{log_prefix}] é–‹å§‹å¼·åˆ¶å®‰è£ä¾è³´...")
                install_start_time = time.monotonic()
                try:
                    # æª¢æŸ¥ uv æ˜¯å¦å­˜åœ¨ï¼Œä¸¦æ±ºå®šå®‰è£æŒ‡ä»¤
                    use_uv = self._ensure_uv_installed()
                    if use_uv:
                        pip_command = [sys.executable, "-m", "uv", "pip", "install", "--system", "-r", str(req_file.resolve())]
                        self._log_manager.log("INFO", f"[{log_prefix}] ä½¿ç”¨ 'uv' é€²è¡Œå¿«é€Ÿå¼·åˆ¶å®‰è£...")
                    else:
                        pip_command = [sys.executable, "-m", "pip", "install", "-r", str(req_file.resolve())]
                        self._log_manager.log("INFO", f"[{log_prefix}] ä½¿ç”¨ 'pip' é€²è¡Œå¼·åˆ¶å®‰è£ã€‚")

                    result = subprocess.run(pip_command, capture_output=True, text=True, encoding='utf-8')

                    if result.stdout and result.stdout.strip():
                        self._log_manager.log("DEBUG", f"[{log_prefix}] å®‰è£ç¨‹å¼ stdout:\n{result.stdout}", "Installer")

                    if result.returncode != 0:
                        error_log = f"å®‰è£å¤±æ•—ï¼è¿”å›ç¢¼: {result.returncode}\n"
                        if result.stderr and result.stderr.strip():
                            error_log += f"STDERR:\n{result.stderr}\n"
                        self._log_manager.log("ERROR", error_log, "Installer")
                        raise subprocess.CalledProcessError(result.returncode, pip_command, output=result.stdout, stderr=result.stderr)

                    self._log_manager.log("SUCCESS", f"âœ… [{log_prefix}] å¼·åˆ¶ä¾è³´å®‰è£å®Œæˆã€‚")
                    self._log_manager.log("INFO", f"--- [{log_prefix}] å®‰è£è€—æ™‚: {time.monotonic() - install_start_time:.2f} ç§’ ---")
                except subprocess.CalledProcessError as e:
                    self._log_manager.log("CRITICAL", f"[{log_prefix}] å¼·åˆ¶ä¾è³´å®‰è£å¤±æ•—ï¼", "Installer")
                    raise

            # --- JULES'S FIX (2025-09-30): çµ±ä¸€å¼·åˆ¶å®‰è£æ‰€æœ‰æ ¸å¿ƒä¾è³´ ---
            # è§£æ±ºæ–¹æ¡ˆï¼šå°‡æ‰€æœ‰æœå‹™å•Ÿå‹•å‰å¿…éœ€çš„ä¾è³´ï¼ˆä¸‹è¼‰å™¨ã€æ ¸å¿ƒã€åˆ†æï¼‰éƒ½ç´å…¥å¼·åˆ¶å®‰è£éšæ®µï¼Œ
            # ç¢ºä¿åœ¨ä»»ä½•æœå‹™ï¼ˆåŒ…æ‹¬ api_server å’ŒèƒŒæ™¯è…³æœ¬ï¼‰å•Ÿå‹•å‰ï¼Œç’°å¢ƒéƒ½å·²æº–å‚™é½Šå…¨ã€‚
            self._log_manager.log("INFO", "æ­¥é©Ÿ 1/4 & 2/4: æ­£åœ¨å¼·åˆ¶å®‰è£æ‰€æœ‰æ ¸å¿ƒæœå‹™ä¾è³´...")

            essential_req_files = {
                "ä¸‹è¼‰å™¨": project_path / "requirements" / "downloader.txt",
                "æ ¸å¿ƒæœå‹™": project_path / "requirements" / "core.txt",
                "åˆ†æåŠŸèƒ½": project_path / "requirements" / "analysis.txt",
                "å•Ÿå‹•å™¨æ ¸å¿ƒ": project_path / "requirements" / "features_core.txt",
            }

            for name, req_file in essential_req_files.items():
                force_install_packages(req_file, name)

            self._log_manager.log("SUCCESS", "âœ… æ‰€æœ‰æ ¸å¿ƒä¾è³´å®‰è£å®Œç•¢ã€‚")

            # --- JULES'S FIX (2025-09-30): ä¿®æ­£é‡‘é‘°æ³¨å…¥æ™‚åº ---
            # å°‡é‡‘é‘°æ³¨å…¥æ“ä½œç§»è‡³ä¾è³´å®‰è£å®Œæˆå¾Œï¼Œä»¥è§£æ±º ModuleNotFoundError çš„æ™‚åºå•é¡Œã€‚
            key_thread = threading.Thread(target=self._inject_keys_background, args=(project_path,), daemon=True)
            key_thread.start()

            # --- éšæ®µ 3: å•Ÿå‹•å¾Œç«¯æœå‹™ ---
            self._log_manager.log("INFO", "æ­¥é©Ÿ 3/4: æ­£åœ¨å•Ÿå‹•å¾Œç«¯å”èª¿å™¨...")
            launch_command = [sys.executable, "src/core/orchestrator.py"]
            process_env = os.environ.copy()
            src_path_str = str((project_path / "src").resolve())
            process_env['PYTHONPATH'] = f"{src_path_str}{os.pathsep}{process_env.get('PYTHONPATH', '')}".strip(os.pathsep)

            # å®‰å…¨åœ°æ³¨å…¥ FRED API é‡‘é‘°
            try:
                from google.colab import userdata
                fred_api_key = userdata.get('FRED_API_KEY')
                if fred_api_key:
                    process_env['FRED_API_KEY'] = fred_api_key
                    self._log_manager.log("SUCCESS", "âœ… æˆåŠŸå¾ Colab Secrets è®€å–ä¸¦æ³¨å…¥ FRED_API_KEYã€‚")
                else:
                    self._log_manager.log("WARN", "ğŸŸ¡ åœ¨ Colab Secrets ä¸­æ‰¾åˆ° FRED_API_KEYï¼Œä½†å…¶å€¼ç‚ºç©ºã€‚")
            except (ImportError, userdata.SecretNotFoundError):
                self._log_manager.log("WARN", "ğŸŸ¡ æœªåœ¨ Colab Secrets ä¸­æ‰¾åˆ° FRED_API_KEYï¼Œéƒ¨åˆ†åœ–è¡¨å¯èƒ½ç„¡æ³•é¡¯ç¤ºã€‚")
            except Exception as e:
                self._log_manager.log("ERROR", f"è®€å– FRED_API_KEY æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

            self.server_process = subprocess.Popen(launch_command, cwd=str(project_path), stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8', preexec_fn=os.setsid, env=process_env)

            # --- éšæ®µ 4: [å·²åœç”¨] V5.5 ä¹‹å¾Œï¼Œå¤§å‹ä¾è³´çš„å®‰è£ç”±ä½¿ç”¨è€…åœ¨éœ€è¦æ™‚è§¸ç™¼ ---
            # èƒŒæ™¯å®‰è£åŸ·è¡Œç·’å·²è¢«ç§»é™¤ï¼Œä»¥æ”¯æ´æ–°çš„ã€Œå®Œå…¨å°±ç·’ã€ä¿¡è™Ÿæ¶æ§‹ã€‚
            self._log_manager.log("INFO", "æ­¥é©Ÿ 4/4: [V5.5] å¤§å‹ä¾è³´å°‡åœ¨éœ€è¦æ™‚ç”±ä½¿ç”¨è€…æ‰‹å‹•å®‰è£ã€‚")

            port_pattern = re.compile(r"PROXY_URL: http://127.0.0.1:(\d+)")
            uvicorn_ready_pattern = re.compile(r"Uvicorn running on")
            server_ready = False

            for line in iter(self.server_process.stdout.readline, ''):
                if self._stop_event.is_set(): break
                line = line.strip()
                self._log_manager.log("DEBUG", line)
                if not self.port and (match := port_pattern.search(line)):
                    self.port = int(match.group(1))
                    self._log_manager.log("INFO", f"âœ… å¾æ—¥èªŒä¸­æˆåŠŸè§£æå‡º API åŸ è™Ÿ: {self.port}")
                if not server_ready and uvicorn_ready_pattern.search(line):
                    server_ready = True
                    self._stats['status'] = "âœ… ä¼ºæœå™¨é‹è¡Œä¸­"
                    self._log_manager.log("SUCCESS", f"âœ… ä¼ºæœå™¨å·²å°±ç·’ï¼æ”¶åˆ° Uvicorn æ¡æ‰‹ä¿¡è™Ÿï¼ (ç¸½è€—æ™‚: {time.monotonic() - self._stats.get('start_time_monotonic', 0):.2f} ç§’)")
                if self.port and server_ready:
                    self.server_ready_event.set()

            return_code = self.server_process.wait()
            if not self.server_ready_event.is_set():
                self._stats['status'] = "âŒ ä¼ºæœå™¨å•Ÿå‹•å¤±æ•—"
                self._log_manager.log("CRITICAL", f"å”èª¿å™¨é€²ç¨‹åœ¨å°±ç·’å‰å·²çµ‚æ­¢ï¼Œè¿”å›ç¢¼: {return_code}ã€‚è«‹æª¢æŸ¥ä¸Šæ–¹æ—¥èªŒä»¥äº†è§£è©³ç´°éŒ¯èª¤ã€‚")
        except Exception as e: self._stats['status'] = "âŒ ç™¼ç”Ÿè‡´å‘½éŒ¯èª¤"; self._log_manager.log("CRITICAL", f"ServerManager åŸ·è¡Œç·’å‡ºéŒ¯: {e}")
        finally: self._stats['status'] = "â¹ï¸ å·²åœæ­¢"

    def start(self): self._thread.start()
    def stop(self):
        self._stop_event.set()
        if self.server_process and self.server_process.poll() is None:
            self._log_manager.log("INFO", "æ­£åœ¨çµ‚æ­¢ä¼ºæœå™¨é€²ç¨‹...")
            try:
                os.killpg(os.getpgid(self.server_process.pid), subprocess.signal.SIGTERM)
                self.server_process.wait(timeout=5)
            except (ProcessLookupError, subprocess.TimeoutExpired):
                try: os.killpg(os.getpgid(self.server_process.pid), subprocess.signal.SIGKILL)
                except ProcessLookupError: pass
        self._thread.join(timeout=2)

class TunnelManager:
    """é€šé“ç®¡ç†å™¨ï¼šä¸¦è¡Œå•Ÿå‹•å¤šå€‹ä»£ç†é€šé“ (Cloudflare, Localtunnel) ä»¥æä¾›å‚™æ´ã€‚"""
    def __init__(self, log_manager, stats_dict, port):
        self._log = log_manager.log; self._stats = stats_dict; self._port = port
        self._stop_event = threading.Event(); self._threads = []; self._processes = []

    def start(self):
        if ENABLE_CLOUDFLARE: self._start_thread(self._run_cloudflared, "Cloudflare")
        if ENABLE_LOCALTUNNEL: self._start_thread(self._run_localtunnel, "Localtunnel")
        if ENABLE_COLAB_PROXY: self._start_thread(self._run_colab_proxy, "Colab")

    def _start_thread(self, target, name):
        thread = threading.Thread(target=target, name=name, daemon=True)
        self._threads.append(thread); thread.start()

    def _update_url_status(self, name, status, url=None, error=None, priority=99, password=None):
        with self._stats.get('_lock', threading.Lock()):
            entry = {"status": status, "priority": priority}
            if url: entry["url"] = url
            if error: entry["error"] = error
            if password: entry["password"] = password
            self._stats.setdefault('urls', {})[name] = entry

    def _ensure_cloudflared_installed(self):
        if Path("./cloudflared").is_file(): return True
        self._log("INFO", "æœªæ‰¾åˆ° Cloudflaredï¼Œæ­£åœ¨ä¸‹è¼‰...", "Cloudflare")
        arch = platform.machine()
        url = f"https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-{'amd64' if arch == 'x86_64' else 'arm64'}"
        try:
            urllib.request.urlretrieve(url, "cloudflared"); os.chmod("cloudflared", 0o755)
            self._log("SUCCESS", "âœ… Cloudflared ä¸‹è¼‰æˆåŠŸã€‚", "Cloudflare"); return True
        except Exception as e: self._log("ERROR", f"Cloudflared ä¸‹è¼‰å¤±æ•—: {e}", "Cloudflare"); return False

    def _run_cloudflared(self):
        self._update_url_status("Cloudflare", "starting", priority=2)
        if not self._ensure_cloudflared_installed(): self._update_url_status("Cloudflare", "error", error="å®‰è£å¤±æ•—"); return
        proc = subprocess.Popen(["./cloudflared", "tunnel", "--url", f"http://127.0.0.1:{self._port}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
        self._processes.append(proc)
        url_pattern = re.compile(r"https://[a-zA-Z0-9-]+\.trycloudflare\.com")
        for line in iter(proc.stdout.readline, ''):
            if self._stop_event.is_set(): break
            self._log("DEBUG", line.strip(), "Cloudflare")
            if match := url_pattern.search(line):
                self._update_url_status("Cloudflare", "ready", url=match.group(0), priority=2); return
        if not self._stop_event.is_set(): self._update_url_status("Cloudflare", "error", error="ç„¡æ³•å¾æ—¥èªŒä¸­è§£æ URL")

    def _ensure_localtunnel_installed(self):
        if "localtunnel@" in subprocess.run(["npm", "list", "-g", "localtunnel"], capture_output=True, text=True).stdout: return True
        self._log("INFO", "æ­£åœ¨å®‰è£ Localtunnel...", "Localtunnel")
        try:
            subprocess.run(["npm", "install", "-g", "localtunnel"], check=True, capture_output=True)
            self._log("SUCCESS", "âœ… Localtunnel å®‰è£æˆåŠŸã€‚", "Localtunnel"); return True
        except subprocess.CalledProcessError as e: self._log("ERROR", f"Localtunnel å®‰è£å¤±æ•—: {e.stderr}", "Localtunnel"); return False

    def _run_localtunnel(self):
        self._update_url_status("Localtunnel", "starting", priority=3)
        if not self._ensure_localtunnel_installed(): self._update_url_status("Localtunnel", "error", error="å®‰è£å¤±æ•—"); return
        proc = subprocess.Popen(["npx", "localtunnel", "--port", str(self._port)], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
        self._processes.append(proc)
        url_pattern = re.compile(r"your url is: (https://[a-zA-Z0-9-]+\.loca\.lt)")
        for line in iter(proc.stdout.readline, ''):
            if self._stop_event.is_set(): break
            self._log("DEBUG", line.strip(), "Localtunnel")
            if match := url_pattern.search(line):
                tunnel_url = match.group(1)
                self._log("INFO", f"âœ… Localtunnel URL '{tunnel_url}' å·²ç²å–ï¼Œæ­£åœ¨æŸ¥è©¢é€šé“å¯†ç¢¼...", "Localtunnel")
                password = "æŸ¥è©¢ä¸­..."
                try:
                    # ä½¿ç”¨ curl æŸ¥è©¢å¯†ç¢¼ (å…¬é–‹ IP)
                    result = subprocess.run(["curl", "https://loca.lt/mytunnelpassword"], capture_output=True, text=True, timeout=10, check=True)
                    password = result.stdout.strip()
                    self._log("SUCCESS", f"âœ… å·²æˆåŠŸç²å– Localtunnel å¯†ç¢¼ã€‚", "Localtunnel")
                except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError) as e:
                    self._log("WARN", f"æŸ¥è©¢ Localtunnel å¯†ç¢¼å¤±æ•—: {e}", "Localtunnel")
                    password = "æŸ¥è©¢å¤±æ•—"
                except Exception as e:
                    self._log("ERROR", f"æŸ¥è©¢ Localtunnel å¯†ç¢¼æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}", "Localtunnel")
                    password = "æœªçŸ¥éŒ¯èª¤"
                self._update_url_status("Localtunnel", "ready", url=tunnel_url, password=password, priority=3)
                return
        if not self._stop_event.is_set(): self._update_url_status("Localtunnel", "error", error="ç„¡æ³•å¾æ—¥èªŒä¸­è§£æ URL")

    def _run_colab_proxy(self):
        self._update_url_status("Colab", "starting", priority=1)
        for attempt in range(10):
            if self._stop_event.is_set(): return
            try:
                url = colab_output.eval_js(f'google.colab.kernel.proxyPort({self._port})', timeout_sec=10)
                if url and url.strip(): self._update_url_status("Colab", "ready", url=url, priority=1); return
                self._log("WARN", f"Colab ä»£ç†å˜—è©¦ #{attempt+1} è¿”å›ç©º URLã€‚", "Colab")
            except Exception as e: self._log("WARN", f"Colab ä»£ç†å˜—è©¦ #{attempt+1} å¤±æ•—: {e}", "Colab")
            time.sleep(2)
        self._update_url_status("Colab", "error", error="é‡è©¦ 10 æ¬¡å¾Œå¤±æ•—")

    def stop(self):
        self._stop_event.set()
        for p in self._processes:
            if p.poll() is None:
                try: p.terminate()
                except ProcessLookupError: pass
        for t in self._threads: t.join(timeout=2)

# ==============================================================================
# SECTION 2: æ ¸å¿ƒåŠŸèƒ½å‡½å¼
# ==============================================================================
def create_log_viewer_html(log_manager, display_manager):
    """ ç”¢ç”Ÿæœ€çµ‚çš„ HTML æ—¥èªŒå ±å‘Šï¼Œæ¡ç´ v15 çš„ textarea æ–¹æ¡ˆä»¥å¢å¼·ç©©å®šæ€§ã€‚ """
    try:
        full_log_history = [f"[{log['timestamp'].isoformat()}] [{log['level']}] {log['message']}" for log in log_manager.get_full_history()]
        screen_output = "\n".join(display_manager._build_output_buffer())

        log_to_display = "\n".join(full_log_history[-LOG_COPY_MAX_LINES:])

        escaped_log_for_textarea = html.escape(log_to_display)
        escaped_screen_for_textarea = html.escape(screen_output)

        screen_id = f"screen-area-{int(time.time() * 1000)}"
        log_id = f"log-area-{int(time.time() * 1000)}"

        return f'''
            <style>
                .collapsible-log {{ margin-top: 15px; margin-bottom: 15px; border: 1px solid #e0e0e0; padding: 12px; border-radius: 8px; background-color: #fafafa; }}
                .collapsible-log summary {{ cursor: pointer; font-weight: bold; color: #333; }}
                .collapsible-log pre {{ background-color: #fff; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 13px; color: #444; max-height: 400px; overflow-y: auto; }}
                .copy-button {{ padding: 8px 16px; margin: 5px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; font-family: sans-serif; }}
                .copy-button:hover {{ background-color: #e0e0e0; }}
            </style>
            <script>
                function copyFromTextarea(elementId, button) {{
                    const ta = document.getElementById(elementId);
                    if (!ta) {{ console.error("Textarea not found:", elementId); return; }}
                    navigator.clipboard.writeText(ta.value).then(() => {{
                        const originalText = button.innerText;
                        button.innerText = "âœ… å·²è¤‡è£½!";
                        setTimeout(() => {{ button.innerText = originalText; }}, 2000);
                    }}, (err) => {{
                        button.innerText = "âŒ è¤‡è£½å¤±æ•—";
                        console.error('è¤‡è£½å¤±æ•—: ', err);
                    }});
                }}
            </script>

            <textarea id="{screen_id}" style="position:absolute; left: -9999px; top: -9999px;" readonly>{escaped_screen_for_textarea}</textarea>
            <textarea id="{log_id}" style="position:absolute; left: -9999px; top: -9999px;" readonly>{escaped_log_for_textarea}</textarea>

            <div>
                <button class="copy-button" onclick="copyFromTextarea('{screen_id}', this)">ğŸ“‹ è¤‡è£½ä¸Šæ–¹æœ€çµ‚ç•«é¢</button>
            </div>
            <details class="collapsible-log">
                <summary>é»æ­¤å±•é–‹/æ”¶åˆæœ€è¿‘ {len(full_log_history[-LOG_COPY_MAX_LINES:])} æ¢è©³ç´°æ—¥èªŒ</summary>
                <div style="margin-top: 12px;">
                    <button class="copy-button" onclick="copyFromTextarea('{log_id}', this)">ğŸ“„ è¤‡è£½ä¸‹æ–¹å®Œæ•´æ—¥èªŒ</button>
                    <pre><code>{escaped_log_for_textarea}</code></pre>
                    <button class="copy-button" onclick="copyFromTextarea('{log_id}', this)">ğŸ“„ è¤‡è£½ä¸‹æ–¹å®Œæ•´æ—¥èªŒ</button>
                </div>
            </details>
        '''
    except Exception as e:
        return f"<p>âŒ ç”¢ç”Ÿæœ€çµ‚æ—¥èªŒå ±å‘Šæ™‚ç™¼ç”ŸéŒ¯èª¤: {html.escape(str(e))}</p>"

def archive_reports(log_manager, start_time, end_time, status):
    print("\n\n" + "="*60 + "\n--- ä»»å‹™çµæŸï¼Œé–‹å§‹åŸ·è¡Œè‡ªå‹•æ­¸æª” ---\n" + "="*60)
    try:
        root_folder = Path(LOG_ARCHIVE_ROOT_FOLDER)
        root_folder.mkdir(exist_ok=True)
        ts_folder_name = start_time.strftime('%Y-%m-%dT%H-%M-%S%z')
        report_dir = root_folder / ts_folder_name
        report_dir.mkdir(exist_ok=True)
        log_history = log_manager.get_full_history()
        detailed_log_content = f"# è©³ç´°æ—¥èªŒ\n\n```\n" + "\n".join([f"[{log['timestamp'].isoformat()}] [{log['level']}] {log['message']}" for log in log_history]) + "\n```"
        (report_dir / "è©³ç´°æ—¥èªŒ.md").write_text(detailed_log_content, encoding='utf-8')
        duration = end_time - start_time
        perf_report_content = f"# æ•ˆèƒ½å ±å‘Š\n\n- **ä»»å‹™ç‹€æ…‹**: {status}\n- **é–‹å§‹æ™‚é–“**: `{start_time.isoformat()}`\n- **çµæŸæ™‚é–“**: `{end_time.isoformat()}`\n- **ç¸½è€—æ™‚**: `{str(duration)}`\n"
        (report_dir / "æ•ˆèƒ½å ±å‘Š.md").write_text(perf_report_content.strip(), encoding='utf-8')
        (report_dir / "ç¶œåˆå ±å‘Š.md").write_text(f"# ç¶œåˆå ±å‘Š\n\n{perf_report_content}\n{detailed_log_content}", encoding='utf-8')
        print(f"âœ… å ±å‘Šå·²æˆåŠŸæ­¸æª”è‡³: {report_dir}")
    except Exception as e: print(f"âŒ æ­¸æª”å ±å‘Šæ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

# ==============================================================================
# SECTION 2.5: å®‰è£ç³»çµ±ç´šä¾è³´ (FFmpeg)
# ==============================================================================
print("æª¢æŸ¥ä¸¦å®‰è£ç³»çµ±ç´šä¾è³´ FFmpeg...")
try:
    if subprocess.run(["which", "ffmpeg"], capture_output=True).returncode != 0:
        print("æœªåµæ¸¬åˆ° FFmpegï¼Œé–‹å§‹å®‰è£...")
        subprocess.run(["apt-get", "update", "-qq"], check=True)
        subprocess.run(["apt-get", "install", "-y", "-qq", "ffmpeg"], check=True)
        print("âœ… FFmpeg å®‰è£å®Œæˆã€‚")
    else:
        print("âœ… FFmpeg å·²å®‰è£ã€‚")
except Exception as e:
    print(f"âŒ å®‰è£ FFmpeg æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

# ==============================================================================
# SECTION 3: ä¸»ç¨‹å¼åŸ·è¡Œå…¥å£
# ==============================================================================
def main():
    start_time_monotonic = time.monotonic()
    shared_stats = {"start_time_monotonic": start_time_monotonic, "status": "åˆå§‹åŒ–...", "urls": {}}
    log_manager, display_manager, server_manager, tunnel_manager = None, None, None, None
    start_time = datetime.now(pytz.timezone(TIMEZONE))
    try:
        log_levels = {name: globals()[name] for name in globals() if name.startswith("SHOW_LOG_LEVEL_")}
        log_manager = LogManager(max_lines=LOG_DISPLAY_LINES, timezone_str=TIMEZONE, log_levels_to_show=log_levels)
        server_manager = ServerManager(log_manager=log_manager, stats_dict=shared_stats)
        display_manager = DisplayManager(log_manager=log_manager, stats_dict=shared_stats, refresh_rate=UI_REFRESH_SECONDS)
        display_manager.start()
        server_manager.start()
        log_manager.log("INFO", f"è¨­å®šä¼ºæœå™¨å•Ÿå‹•è¶…æ™‚æ™‚é–“ç‚º {SERVER_READY_TIMEOUT} ç§’...")
        if server_manager.server_ready_event.wait(timeout=SERVER_READY_TIMEOUT):
            if not server_manager.port:
                log_manager.log("CRITICAL", "ä¼ºæœå™¨å·²å°±ç·’ï¼Œä½†æœªèƒ½è§£æå‡º API åŸ è™Ÿã€‚ç„¡æ³•å»ºç«‹ä»£ç†é€£çµã€‚")
            else:
                log_manager.log("SUCCESS", f"âœ… å¾Œç«¯æœå‹™å·²åœ¨åŸ è™Ÿ {server_manager.port} ä¸Šå°±ç·’ï¼Œæ­£åœ¨å•Ÿå‹•æ‰€æœ‰ä»£ç†é€šé“...")
                tunnel_manager = TunnelManager(log_manager=log_manager, stats_dict=shared_stats, port=server_manager.port)
                tunnel_manager.start()
        else:
            shared_stats['status'] = f"âŒ ä¼ºæœå™¨å•Ÿå‹•è¶…æ™‚ ({SERVER_READY_TIMEOUT}ç§’)"
            log_manager.log("CRITICAL", f"ä¼ºæœå™¨åœ¨ {SERVER_READY_TIMEOUT} ç§’å…§æœªèƒ½å°±ç·’ã€‚ POC é©—è­‰å¤±æ•—ã€‚æ­£åœ¨å¼·åˆ¶çµ‚æ­¢...")
            # é€™æœƒè§¸ç™¼ finally å€å¡Šä¾†æ¸…ç†æ‰€æœ‰ç¨‹åº
            raise SystemExit(f"POC FAILED: Server did not start within {SERVER_READY_TIMEOUT} seconds.")
        while server_manager._thread.is_alive(): time.sleep(1)
    except (KeyboardInterrupt, SystemExit) as e:
        if isinstance(e, SystemExit):
            if log_manager: log_manager.log("CRITICAL", f"ç³»çµ±å› è‡´å‘½éŒ¯èª¤é€€å‡º: {e}")
        else: # KeyboardInterrupt
            if log_manager: log_manager.log("WARN", "ğŸ›‘ åµæ¸¬åˆ°ä½¿ç”¨è€…æ‰‹å‹•ä¸­æ–·...")
    except Exception as e:
        if log_manager: log_manager.log("CRITICAL", f"âŒ ç™¼ç”Ÿæœªé æœŸçš„è‡´å‘½éŒ¯èª¤: {e}")
        else: print(f"âŒ ç™¼ç”Ÿæœªé æœŸçš„è‡´å‘½éŒ¯èª¤: {e}")
    finally:
        if display_manager and display_manager._thread.is_alive(): display_manager.stop()
        if 'tunnel_manager' in locals() and tunnel_manager: tunnel_manager.stop()
        if server_manager: server_manager.stop()
        end_time = datetime.now(pytz.timezone(TIMEZONE))
        if log_manager and display_manager:
            clear_output(); print("\n".join(display_manager._build_output_buffer()))
            print("\n--- âœ… æ‰€æœ‰ä»»å‹™å®Œæˆï¼Œç³»çµ±å·²å®‰å…¨é—œé–‰ ---")
            display(HTML(create_log_viewer_html(log_manager, display_manager)))
            archive_reports(log_manager, start_time, end_time, shared_stats.get('status', 'æœªçŸ¥'))

if __name__ == "__main__":
    main()
