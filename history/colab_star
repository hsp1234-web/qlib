# -*- coding: utf-8 -*-
# ╔══════════════════════════════════════════════════════════════════╗
# ║                                                                      ║
# ║   ✨🐺 善狼一鍵啟動器 (v50) 🐺                                   ✨🐺 ║
# ║                                                                      ║
# ╠══════════════════════════════════════════════════════════════════╣
# ║                                                                      ║
# ║ - V48 更新日誌 (2025-09-30):                                         ║
# ║   - **功能**: 新增日誌多行顯示功能，優化行動裝置可讀性。             ║
# ║   - **修復**: 改用命令列參數傳遞 FRED 金鑰，徹底解決注入失敗問題。   ║
# ║ - V47 更新日誌 (2025-09-30):                                         ║
# ║   - **修復**: 修正 FRED 金鑰未被注入資料庫導致前端無法顯示的問題。   ║
# ║   - **修復**: 調整啟動時序，解決因競爭條件導致的首次金鑰自動驗證失敗 ║
# ║     問題。                                                         ║
# ║   - **調整**: 將預設分支更新至 `91`。                                ║
# ║ - V46 更新日誌 (2025-09-30):                                         ║
# ║   - **重構**: 調整啟動時序，修復因競爭條件導致的金鑰載入與驗證失敗   ║
# ║     問題，大幅提升啟動穩定性。                                     ║
# ║ - V45 更新日誌 (2025-09-30):                                         ║
# ║   - **修復**: 修正 `colabPro.py` 執行異常問題。                      ║
# ║   - **調整**: 更新預設分支號碼為 `90.1`，並同步版本號至 `v45`。      ║
# ║ - V39 更新日誌 (2025-09-30):                                         ║
# ║   - **戰略修正**: 採用最小化修改策略，為 FRED 金鑰新增前端狀態探測   ║
# ║     接口，以確保系統穩定性。                                       ║
# ║ - V32 更新日誌 (2025-09-27):                                         ║
# ║   - **新增功能**: 自動偵測並顯示 `localtunnel` 的通道密碼，無需     ║
# ║     使用者手動查詢。                                               ║
# ║ - V28.1 更新日誌 (2025-09-16):                                       ║
# ║   - **增強日誌**: 為金鑰自動驗證流程添加更詳細的日誌記錄，以便追蹤   ║
# ║     執行狀態並診斷潛在問題。                                       ║
# ║ - V28 更新日誌 (2025-09-16):                                         ║
# ║   - **修復金鑰驗證**: 調整金鑰驗證時的子程序環境，解決高階硬體上     ║
# ║     因環境變數不完整而導致的驗證失敗問題。                         ║
# ║   - **更新預設分支**: 將預設分支號碼更新為 `25.4`。                  ║
# ║                                                                      ║
# ╚══════════════════════════════════════════════════════════════════╝

#@title ✨🐺 善狼一鍵啟動器 (v50)  🐺 { vertical-output: true, display-mode: "form" }
#@markdown ---
#@markdown ### **核心設定**
#@markdown > **請確認以下兩個核心設定。**
#@markdown ---
#@markdown **後端版本分支或標籤**
TARGET_BRANCH_OR_TAG = "141.2" #@param {type:"string"}
#@markdown **自動從 Colab Secrets 載入的金鑰數量 (0-20)**
#@markdown > 輸入 `2` 將載入 `GOOGLE_API_KEY`, `_1`, `_2` 共三組金鑰。
KEY_LOAD_COUNT_LIMIT = 2 #@param {type:"number"}
#@markdown **日誌顯示行數 (1-15)**
#@markdown > 設定單條日誌在儀表板中佔據的總行數。`1` 為單行緊湊模式，`2-15` 為多行模式。
LOG_SPLIT_LINES = 2 #@param {type:"number"}
#@markdown ---
#@markdown > **設定完成後，點擊「執行」按鈕。**
#@markdown ---

# --- JULES'S NEW FEATURE (2025-09-30): 參數邊界驗證 ---
# 確保使用者輸入的日誌行數在合理範圍內，防止介面錯亂。
if not 1 <= LOG_SPLIT_LINES <= 15:
    print(f"⚠️ 警告：日誌顯示行數設定值 ({LOG_SPLIT_LINES}) 超出有效範圍 (1-15)。將自動使用預設值 2。")
    LOG_SPLIT_LINES = 2

# ==============================================================================
# SECTION A: 進階設定 (可在此處修改)
# 說明：以下為不常變動的進階設定。若需調整，請直接修改此區塊的變數值。
# 設計理念：將高階設定與使用者常用設定分離，讓大多數使用者只需關注上方表單即可。
# ==============================================================================

# Part 1: 核心專案設定 (固定)
# Git 儲存庫 URL
REPOSITORY_URL = "https://github.com/hsp1234-web/20250910.git"
# 在 Colab 本機中建立的專案資料夾名稱
PROJECT_FOLDER_NAME = "wolf_project"
# 是否在每次啟動時，都強制刪除舊的專案資料夾並重新 clone。設為 True 可確保程式碼永遠是最新版。
FORCE_REPO_REFRESH = True

# Part 1.5: 通道啟用設定
# 啟用 Colab 內建的代理服務，通常最穩定。
ENABLE_COLAB_PROXY = True
# 啟用 localtunnel 作為備援通道。
ENABLE_LOCALTUNNEL = True
# 啟用 Cloudflare Tunnel 作為備援通道。
ENABLE_CLOUDFLARE = True

# Part 2: 儀表板與監控設定
# 純文字儀表板的刷新頻率（秒）。
UI_REFRESH_SECONDS = 0.5
# 儀表板上顯示的日誌行數上限。
LOG_DISPLAY_LINES = 5
# 設定系統的時區，確保日誌時間戳正確。
TIMEZONE = "Asia/Taipei"

# Part 3: 日誌等級可見性
# 控制哪些等級的日誌訊息會顯示在儀表板上。
SHOW_LOG_LEVEL_BATTLE = True
SHOW_LOG_LEVEL_SUCCESS = True
SHOW_LOG_LEVEL_INFO = True
SHOW_LOG_LEVEL_WARN = True
SHOW_LOG_LEVEL_ERROR = True
SHOW_LOG_LEVEL_CRITICAL = True
SHOW_LOG_LEVEL_DEBUG = True

# Part 4: 報告與歸檔設定
# 腳本執行結束後，自動儲存日誌與報告的根資料夾名稱。
LOG_ARCHIVE_ROOT_FOLDER = "paper"
# 等待後端伺服器啟動的最長秒數，超過此時間則視為失敗。
SERVER_READY_TIMEOUT = 150
# 最終複製到剪貼簿或報告中的日誌最大行數。
LOG_COPY_MAX_LINES = 5000

# ==============================================================================
# SECTION 0: 環境準備與核心依賴導入 (此處開始為核心程式，通常無需修改)
# 設計理念：此區塊負責所有基礎設定與模組導入，確保後續程式能順利執行。
# ==============================================================================
import sys
import subprocess
import socket
import platform
import urllib.request
# 嘗試導入 pytz，如果失敗則自動安裝。這是處理時區所必需的套件。
try:
    import pytz
except ImportError:
    print("正在安裝 pytz...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "pytz"])
    import pytz

import os
import shutil
from pathlib import Path
import time
from datetime import datetime
import threading
from collections import deque
import re
import json
import html
import requests
from IPython.display import clear_output, display, HTML
from google.colab import output as colab_output

# ==============================================================================
# SECTION 1: 管理器類別定義 (Managers)
# 設計理念：採用物件導向的設計，將不同職責（日誌、顯示、伺服器管理）封裝到獨立的類別中，
# 使得程式碼結構更清晰、更容易維護。
# ==============================================================================

class LogManager:
    """日誌管理器：負責記錄、過濾和儲存所有日誌訊息。"""
    def __init__(self, max_lines, timezone_str, log_levels_to_show):
        # 使用 deque 儲存日誌，這是一個雙向佇列，當超過最大行數時會自動丟棄舊的日誌，效率很高。
        self._log_deque = deque(maxlen=max_lines)
        # 儲存完整的日誌歷史紀錄，用於最後的報告生成。
        self._full_history = []
        # 使用執行緒鎖，確保在多執行緒環境下對日誌的存取是安全的。
        self._lock = threading.Lock()
        self.timezone = pytz.timezone(timezone_str)
        self.log_levels_to_show = log_levels_to_show

    def log(self, level: str, message: str, source: str = "SYSTEM"):
        """記錄一條新的日誌。"""
        with self._lock:
            log_entry = {"timestamp": datetime.now(self.timezone), "level": level.upper(), "message": str(message), "source": source}
            self._log_deque.append(log_entry)
            self._full_history.append(log_entry)

    def get_display_logs(self) -> list:
        """獲取需要在儀表板上顯示的日誌（經過等級過濾）。"""
        with self._lock:
            all_logs = list(self._log_deque)
            # 根據 Part 3 的設定，過濾掉不需顯示的日誌等級。
            return [log for log in all_logs if self.log_levels_to_show.get(f"SHOW_LOG_LEVEL_{log['level']}", False)]

    def get_full_history(self) -> list:
        """獲取完整的日誌歷史。"""
        with self._lock:
            return self._full_history

# 定義用於在終端機中顯示彩色文字的 ANSI escape codes。
ANSI_COLORS = {
    "SUCCESS": "\033[32m", "WARN": "\033[33m", "ERROR": "\033[31m",
    "CRITICAL": "\033[31m", "RESET": "\033[0m"
}

def colorize(text, level):
    """根據日誌等級，為文字添加顏色。"""
    return f"{ANSI_COLORS.get(level, '')}{text}{ANSI_COLORS['RESET']}"

class DisplayManager:
    """顯示管理器：在背景執行緒中負責繪製純文字動態儀表板。"""
    def __init__(self, log_manager, stats_dict, refresh_rate):
        self._log_manager = log_manager
        # stats_dict 是一個共享的字典，用於在不同管理器之間傳遞狀態訊息（例如 CPU 使用率、公開網址等）。
        self._stats = stats_dict
        self._refresh_rate = refresh_rate
        # 使用 threading.Event 來優雅地停止背景執行緒。
        self._stop_event = threading.Event()
        # 將儀表板的繪製放在一個獨立的 daemon 執行緒中，這樣主程式退出時它也會自動退出。
        self._thread = threading.Thread(target=self._run, daemon=True)

    def _build_output_buffer(self) -> list[str]:
        """建立儀表板的每一幀畫面內容。"""
        output_buffer = ["✨🐺 善狼一鍵啟動器 (v50) 🐺", ""]
        logs_to_display = self._log_manager.get_display_logs()

        # 日誌格式化邏輯
        for log in logs_to_display:
            ts = log['timestamp'].strftime('%H:%M:%S')
            level, msg = log['level'], log['message']

            if LOG_SPLIT_LINES == 1:
                # --- 單行緊湊模式 ---
                output_buffer.append(f"[{ts}] {colorize(f'[{level:^8}]', level)} {msg}")
            else:
                # --- 多行舒適模式 ---
                # 第一行顯示時間和等級
                header = f"[{ts}] {colorize(f'[{level:^8}]', level)}"
                output_buffer.append(header)

                # 後續行顯示訊息本文，並根據設定的行數自動換行
                num_message_lines = max(1, LOG_SPLIT_LINES - 1)

                if not msg:
                    continue

                avg_len = len(msg) / num_message_lines
                start_index = 0
                for i in range(num_message_lines):
                    if start_index >= len(msg):
                        break
                    end_index = len(msg) if i == num_message_lines - 1 else int(start_index + avg_len + 0.5)
                    line_content = msg[start_index:end_index].strip()
                    if line_content:
                        output_buffer.append(line_content)
                    start_index = end_index

        # 顯示所有代理通道的公開網址
        urls = self._stats.get('urls', {})
        if urls:
            if logs_to_display: output_buffer.append("")
            output_buffer.append("🔗 公開存取網址 (Public URLs):")
            # 根據 priority 排序，讓最穩定的通道顯示在最前面。
            sorted_urls = sorted(urls.items(), key=lambda item: item[1].get('priority', 99))
            for name, url_info in sorted_urls:
                if url_info['status'] == 'ready':
                    line = f"  - {name}: {colorize(url_info['url'], 'SUCCESS')}"
                    if 'password' in url_info:
                        line += f" (密碼: {url_info['password']})"
                    output_buffer.append(line)
                elif url_info['status'] == 'starting':
                    output_buffer.append(f"  - {name}: 正在啟動中...")
                else:
                    output_buffer.append(f"  - {name}: {colorize(url_info.get('error', '發生錯誤'), 'ERROR')}")

        # 顯示系統資源使用率和執行時間
        try:
            import psutil
            cpu, ram = f"{psutil.cpu_percent():5.1f}%", f"{psutil.virtual_memory().percent:5.1f}%"
        except ImportError:
            cpu, ram = "  N/A ", "  N/A "
        elapsed = time.monotonic() - self._stats.get("start_time_monotonic", time.monotonic())
        mins, secs = divmod(elapsed, 60)
        output_buffer.append("")
        output_buffer.append(f"⏱️ {int(mins):02d}分{int(secs):02d}秒 | 💻 CPU: {cpu} | 🧠 RAM: {ram} | 🔥 狀態: {self._stats.get('status', '初始化...')}")
        return output_buffer

    def _run(self):
        """背景執行緒的主循環，定期重繪儀表板。"""
        while not self._stop_event.is_set():
            try:
                # 清除舊的輸出，然後印出新的畫面
                clear_output(wait=True)
                print("\n".join(self._build_output_buffer()), flush=True)
                time.sleep(self._refresh_rate)
            except Exception as e:
                self._log_manager.log("ERROR", f"DisplayManager 執行緒發生錯誤: {e}")
                time.sleep(5)

    def start(self): self._thread.start()
    def stop(self): self._stop_event.set(); self._thread.join(timeout=2)

class ServerManager:
    """伺服器管理器：負責啟動、停止和監控後端伺服器子進程。"""
    def __init__(self, log_manager, stats_dict):
        self._log_manager = log_manager; self._stats = stats_dict
        self.server_process = None; self.server_ready_event = threading.Event()
        self._stop_event = threading.Event()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self.port = None

    def _ensure_uv_installed(self):
        """檢查 `uv` (一個快速的 Python 套件安裝器) 是否已安裝，若否，則嘗試安裝。"""
        try:
            subprocess.check_call([sys.executable, "-m", "uv", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self._log_manager.log("INFO", "✅ 'uv' 加速器已安裝。")
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            self._log_manager.log("INFO", "未找到 'uv'，正在嘗試安裝...")
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "uv"])
                self._log_manager.log("SUCCESS", "✅ 'uv' 加速器安裝成功！")
                return True
            except subprocess.CalledProcessError:
                self._log_manager.log("WARN", "安裝 'uv' 失敗，將退回使用 'pip'。")
                return False

    def _inject_keys_background(self, project_path: Path):
        """
        [背景執行] 負責從 Colab Secrets (一個安全儲存敏感資訊的地方) 獲取金鑰並透過腳本注入到應用程式中。
        """
        self._log_manager.log("INFO", "[背景] 開始執行金鑰注入...")
        try:
            # 核心金鑰注入邏輯：
            # 在 Colab 中，只有主執行緒才能存取 Secrets。因此，我們在主執行緒中獲取所有金鑰，
            # 然後透過命令列參數安全地傳遞給一個獨立的子程序（key_injector_script）來執行注入操作。
            key_injector_script = project_path / "scripts" / "colab_key_injector.py"
            if not key_injector_script.is_file():
                self._log_manager.log("WARN", f"[背景] 未找到金鑰注入腳本 '{key_injector_script}'，跳過金鑰載入。")
                return

            from google.colab import userdata
            self._log_manager.log("INFO", "[背景] 正在從 Colab Secrets 獲取金鑰...")

            # 根據使用者在表單中的設定，決定要讀取多少個金鑰。
            base_key_name = "GOOGLE_API_KEY"
            target_key_names = [base_key_name]
            if KEY_LOAD_COUNT_LIMIT > 0:
                target_key_names.extend([f"{base_key_name}_{i}" for i in range(1, KEY_LOAD_COUNT_LIMIT + 1)])

            keys_to_inject = []
            for key_name in target_key_names:
                try:
                    key_value = userdata.get(key_name)
                    if key_value and key_value.strip():
                        keys_to_inject.append(key_value)
                        self._log_manager.log("INFO", f"[背景] ✅ 已成功獲取金鑰 '{key_name}'。")
                except userdata.SecretNotFoundError:
                    self._log_manager.log("INFO", f"[背景] 🟡 未在 Colab Secrets 中找到金鑰 '{key_name}'，跳過。")
                except Exception as e:
                    self._log_manager.log("WARN", f"[背景] 讀取金鑰 '{key_name}' 時發生錯誤: {e}，跳過。")

            if not keys_to_inject:
                 self._log_manager.log("WARN", "[背景] 未從 Colab Secrets 中獲取到任何金鑰，跳過注入。")
                 return

            # 將所有金鑰合併成一個字串，準備傳遞給子程序。
            keys_string = "\n".join(keys_to_inject)
            command = [
                sys.executable, str(key_injector_script.resolve()),
                "--mode", "manual", "--manual-keys", keys_string
            ]

            # 同樣地，安全地讀取並傳遞 FRED API 金鑰。
            fred_api_key = None
            try:
                fred_api_key = userdata.get('FRED_API_KEY')
                if fred_api_key and fred_api_key.strip():
                    command.extend(["--fred-key", fred_api_key])
                    self._log_manager.log("INFO", "[背景] 成功讀取 FRED_API_KEY 並準備透過參數傳遞。", "KeyInjector")
            except Exception:
                self._log_manager.log("WARN", "[背景] 未能在 Colab Secrets 中找到 FRED_API_KEY。", "KeyInjector")

            # 執行注入腳本，並即時讀取其輸出，顯示在主儀表板上。
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
            for line in iter(process.stdout.readline, ''):
                self._log_manager.log("INFO", f"[背景] {line.strip()}", "KeyInjector")
            process.wait()

            if process.returncode == 0:
                self._log_manager.log("SUCCESS", "[背景] ✅ 金鑰注入腳本執行完畢。")
            else:
                self._log_manager.log("WARN", f"[背景] 金鑰注入腳本執行結束，但返回碼為 {process.returncode}。")

        except ImportError:
            self._log_manager.log("WARN", "[背景] 無法匯入 google.colab.userdata，可能並非在 Colab 環境。跳過金鑰注入。")
        except Exception as e:
            self._log_manager.log("ERROR", f"[背景] 執行金鑰注入時發生未預期的錯誤: {e}")
        finally:
            self._log_manager.log("INFO", "[背景] 金鑰注入執行緒結束。")


    def _run(self):
        """伺服器管理執行緒的主體，負責整個啟動流程。"""
        try:
            self._log_manager.log("BATTLE", "=== 啟動器核心流程開始 ===")
            self._stats['status'] = "🚀 準備執行環境..."

            # 步驟 1: 下載或更新程式碼
            project_path = Path(PROJECT_FOLDER_NAME)
            if FORCE_REPO_REFRESH and project_path.exists():
                self._log_manager.log("INFO", f"偵測到舊的專案資料夾 '{project_path}'，正在強制刪除...")
                shutil.rmtree(project_path)

            self._log_manager.log("INFO", f"正在從 Git 下載 (分支: {TARGET_BRANCH_OR_TAG})...")
            git_command = ["git", "clone", "--branch", TARGET_BRANCH_OR_TAG, "--depth", "1", REPOSITORY_URL, str(project_path)]
            result = subprocess.run(git_command, check=False, capture_output=True, text=True, encoding='utf-8')
            if result.returncode != 0:
                error_message = f"""Git clone 失敗! 返回碼: {result.returncode}\n--- STDOUT ---\n{result.stdout}\n--- STDERR ---\n{result.stderr}\n"""
                self._log_manager.log("CRITICAL", error_message)
                return
            self._log_manager.log("INFO", "✅ Git 倉庫下載完成。")
            self._log_manager.log("INFO", f"--- Git Clone 完成 (耗時: {time.monotonic() - self._stats.get('start_time_monotonic', 0):.2f} 秒) ---")

            # 將專案的 src 目錄加入到 Python 的搜尋路徑中，這樣才能正確導入專案內的模組。
            project_src_path = project_path / "src"
            project_src_path_str = str(project_src_path.resolve())
            if project_src_path_str not in sys.path:
                sys.path.insert(0, project_src_path_str)

            # 步驟 2: 初始化資料庫
            self._log_manager.log("INFO", "🔩 步驟 1/5: 正在初始化資料庫結構...")
            try:
                # 動態導入資料庫初始化腳本並執行。
                from db import initialize_database as key_db_init
                from io import StringIO
                import contextlib
                init_log_stream = StringIO()
                with contextlib.redirect_stdout(init_log_stream):
                    key_db_init.initialize()
                init_logs = init_log_stream.getvalue().strip()
                if init_logs:
                    for line in init_logs.split('\n'):
                        self._log_manager.log("INFO", f"[DB_Init] {line}", "Database")
                self._log_manager.log("SUCCESS", "✅ 金鑰資料庫結構已是最新版本。")

                from db.database import initialize_database as task_db_init, add_system_log
                task_db_init()
                add_system_log("colab_setup", "INFO", "Git repository cloned and DB schema updated.")
                self._log_manager.log("INFO", "✅ 舊版任務資料庫初始化成功。")
            except Exception as e:
                self._log_manager.log("CRITICAL", f"資料庫初始化失敗，這是一個致命錯誤，啟動中止。 {e}", "Database")
                return

            # 步驟 3: 安裝 Python 依賴套件
            def force_install_packages(req_file: Path, log_prefix: str):
                """一個簡化的安裝函式，不檢查，直接安裝。優先使用 uv 加速器。"""
                if not req_file.is_file():
                    self._log_manager.log("WARN", f"[{log_prefix}] 依賴檔案 '{req_file.name}' 不存在，跳過。")
                    return
                self._log_manager.log("INFO", f"[{log_prefix}] 開始強制安裝依賴...")
                install_start_time = time.monotonic()
                try:
                    use_uv = self._ensure_uv_installed()
                    if use_uv:
                        pip_command = [sys.executable, "-m", "uv", "pip", "install", "--system", "-r", str(req_file.resolve())]
                        self._log_manager.log("INFO", f"[{log_prefix}] 使用 'uv' 進行快速強制安裝...")
                    else:
                        pip_command = [sys.executable, "-m", "pip", "install", "-r", str(req_file.resolve())]
                        self._log_manager.log("INFO", f"[{log_prefix}] 使用 'pip' 進行強制安裝。")
                    result = subprocess.run(pip_command, capture_output=True, text=True, encoding='utf-8')
                    if result.stdout and result.stdout.strip():
                        self._log_manager.log("DEBUG", f"[{log_prefix}] 安裝程式 stdout:\n{result.stdout}", "Installer")
                    if result.returncode != 0:
                        error_log = f"安裝失敗！返回碼: {result.returncode}\n"
                        if result.stderr and result.stderr.strip(): error_log += f"STDERR:\n{result.stderr}\n"
                        self._log_manager.log("ERROR", error_log, "Installer")
                        raise subprocess.CalledProcessError(result.returncode, pip_command, output=result.stdout, stderr=result.stderr)
                    self._log_manager.log("SUCCESS", f"✅ [{log_prefix}] 強制依賴安裝完成。")
                    self._log_manager.log("INFO", f"--- [{log_prefix}] 安裝耗時: {time.monotonic() - install_start_time:.2f} 秒 ---")
                except subprocess.CalledProcessError as e:
                    self._log_manager.log("CRITICAL", f"[{log_prefix}] 強制依賴安裝失敗！", "Installer")
                    raise

            # 強制安裝所有核心服務所需的依賴。
            self._log_manager.log("INFO", "步驟 1/4 & 2/4: 正在強制安裝所有核心服務依賴...")
            essential_req_files = {
                "下載器": project_path / "requirements" / "downloader.txt",
                "核心服務": project_path / "requirements" / "core.txt",
                "分析功能": project_path / "requirements" / "analysis.txt",
                "啟動器核心": project_path / "requirements" / "features_core.txt",
            }
            for name, req_file in essential_req_files.items():
                force_install_packages(req_file, name)
            self._log_manager.log("SUCCESS", "✅ 所有核心依賴安裝完畢。")

            # 步驟 4: 在背景啟動金鑰注入程序
            # 將金鑰注入操作移至依賴安裝完成後，以解決 ModuleNotFoundError 的時序問題。
            key_thread = threading.Thread(target=self._inject_keys_background, args=(project_path,), daemon=True)
            key_thread.start()

            # 步驟 5: 啟動後端伺服器
            self._log_manager.log("INFO", "步驟 3/4: 正在啟動後端協調器...")
            launch_command = [sys.executable, "src/core/orchestrator.py"]
            process_env = os.environ.copy()
            src_path_str = str((project_path / "src").resolve())
            process_env['PYTHONPATH'] = f"{src_path_str}{os.pathsep}{process_env.get('PYTHONPATH', '')}".strip(os.pathsep)

            # 安全地將 FRED API 金鑰注入到伺服器的環境變數中。
            try:
                from google.colab import userdata
                fred_api_key = userdata.get('FRED_API_KEY')
                if fred_api_key:
                    process_env['FRED_API_KEY'] = fred_api_key
                    self._log_manager.log("SUCCESS", "✅ 成功從 Colab Secrets 讀取並注入 FRED_API_KEY。")
                else:
                    self._log_manager.log("WARN", "🟡 在 Colab Secrets 中找到 FRED_API_KEY，但其值為空。")
            except (ImportError, userdata.SecretNotFoundError):
                self._log_manager.log("WARN", "🟡 未在 Colab Secrets 中找到 FRED_API_KEY，部分圖表可能無法顯示。")
            except Exception as e:
                self._log_manager.log("ERROR", f"讀取 FRED_API_KEY 時發生錯誤: {e}")

            # 使用 Popen 啟動後端伺服器子進程。
            self.server_process = subprocess.Popen(launch_command, cwd=str(project_path), stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8', preexec_fn=os.setsid, env=process_env)

            # 步驟 6: 監聽伺服器日誌，等待其就緒
            self._log_manager.log("INFO", "步驟 4/4: 等待後端伺服器就緒...")
            port_pattern = re.compile(r"PROXY_URL: http://127.0.0.1:(\d+)")
            uvicorn_ready_pattern = re.compile(r"Uvicorn running on")
            server_ready = False

            # 逐行讀取伺服器的輸出日誌。
            for line in iter(self.server_process.stdout.readline, ''):
                if self._stop_event.is_set(): break
                line = line.strip()
                self._log_manager.log("DEBUG", line)
                # 從日誌中解析出伺服器運行的埠號。
                if not self.port and (match := port_pattern.search(line)):
                    self.port = int(match.group(1))
                    self._log_manager.log("INFO", f"✅ 從日誌中成功解析出 API 埠號: {self.port}")
                # 偵測到 "Uvicorn running on" 字樣，表示伺服器已成功啟動。
                if not server_ready and uvicorn_ready_pattern.search(line):
                    server_ready = True
                    self._stats['status'] = "✅ 伺服器運行中"
                    self._log_manager.log("SUCCESS", f"✅ 伺服器已就緒！ (總耗時: {time.monotonic() - self._stats.get('start_time_monotonic', 0):.2f} 秒)")
                # 當埠號和就緒信號都獲取到後，觸發事件，通知其他管理器可以開始工作了。
                if self.port and server_ready:
                    self.server_ready_event.set()

            return_code = self.server_process.wait()
            if not self.server_ready_event.is_set():
                self._stats['status'] = "❌ 伺服器啟動失敗"
                self._log_manager.log("CRITICAL", f"協調器進程在就緒前已終止，返回碼: {return_code}。請檢查日誌。")
        except Exception as e: self._stats['status'] = "❌ 發生致命錯誤"; self._log_manager.log("CRITICAL", f"ServerManager 執行緒出錯: {e}")
        finally: self._stats['status'] = "⏹️ 已停止"

    def start(self): self._thread.start()
    def stop(self):
        """優雅地停止伺服器子進程。"""
        self._stop_event.set()
        if self.server_process and self.server_process.poll() is None:
            self._log_manager.log("INFO", "正在終止伺服器進程...")
            try:
                # 使用 os.killpg 來確保能終止整個進程組，避免殭屍進程。
                os.killpg(os.getpgid(self.server_process.pid), subprocess.signal.SIGTERM)
                self.server_process.wait(timeout=5)
            except (ProcessLookupError, subprocess.TimeoutExpired):
                try: os.killpg(os.getpgid(self.server_process.pid), subprocess.signal.SIGKILL)
                except ProcessLookupError: pass
        self._thread.join(timeout=2)

class TunnelManager:
    """通道管理器：並行啟動多個代理通道 (Cloudflare, Localtunnel) 以提供備援，增加連線成功率。"""
    def __init__(self, log_manager, stats_dict, port):
        self._log = log_manager.log; self._stats = stats_dict; self._port = port
        self._stop_event = threading.Event(); self._threads = []; self._processes = []

    def start(self):
        """並行啟動所有已啟用的通道。"""
        if ENABLE_CLOUDFLARE: self._start_thread(self._run_cloudflared, "Cloudflare")
        if ENABLE_LOCALTUNNEL: self._start_thread(self._run_localtunnel, "Localtunnel")
        if ENABLE_COLAB_PROXY: self._start_thread(self._run_colab_proxy, "Colab")

    def _start_thread(self, target, name):
        thread = threading.Thread(target=target, name=name, daemon=True)
        self._threads.append(thread); thread.start()

    def _update_url_status(self, name, status, url=None, error=None, priority=99, password=None):
        """更新共享狀態字典中的 URL 狀態。"""
        with self._stats.get('_lock', threading.Lock()):
            entry = {"status": status, "priority": priority}
            if url: entry["url"] = url
            if error: entry["error"] = error
            if password: entry["password"] = password
            self._stats.setdefault('urls', {})[name] = entry

    def _ensure_cloudflared_installed(self):
        """檢查並安裝 Cloudflare Tunnel 客戶端。"""
        if Path("./cloudflared").is_file(): return True
        self._log("INFO", "未找到 Cloudflared，正在下載...", "Cloudflare")
        arch = platform.machine()
        url = f"https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-{'amd64' if arch == 'x86_64' else 'arm64'}"
        try:
            urllib.request.urlretrieve(url, "cloudflared"); os.chmod("cloudflared", 0o755)
            self._log("SUCCESS", "✅ Cloudflared 下載成功。", "Cloudflare"); return True
        except Exception as e: self._log("ERROR", f"Cloudflared 下載失敗: {e}", "Cloudflare"); return False

    def _run_cloudflared(self):
        """啟動 Cloudflare Tunnel。"""
        self._update_url_status("Cloudflare", "starting", priority=2)
        if not self._ensure_cloudflared_installed(): self._update_url_status("Cloudflare", "error", error="安裝失敗"); return
        proc = subprocess.Popen(["./cloudflared", "tunnel", "--url", f"http://127.0.0.1:{self._port}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
        self._processes.append(proc)
        url_pattern = re.compile(r"https://[a-zA-Z0-9-]+\.trycloudflare\.com")
        for line in iter(proc.stdout.readline, ''):
            if self._stop_event.is_set(): break
            self._log("DEBUG", line.strip(), "Cloudflare")
            if match := url_pattern.search(line):
                self._update_url_status("Cloudflare", "ready", url=match.group(0), priority=2); return
        if not self._stop_event.is_set(): self._update_url_status("Cloudflare", "error", error="無法從日誌中解析 URL")

    def _ensure_localtunnel_installed(self):
        """檢查並安裝 Localtunnel。"""
        if "localtunnel@" in subprocess.run(["npm", "list", "-g", "localtunnel"], capture_output=True, text=True).stdout: return True
        self._log("INFO", "正在安裝 Localtunnel...", "Localtunnel")
        try:
            subprocess.run(["npm", "install", "-g", "localtunnel"], check=True, capture_output=True)
            self._log("SUCCESS", "✅ Localtunnel 安裝成功。", "Localtunnel"); return True
        except subprocess.CalledProcessError as e: self._log("ERROR", f"Localtunnel 安裝失敗: {e.stderr}", "Localtunnel"); return False

    def _run_localtunnel(self):
        """啟動 Localtunnel 並自動獲取通道密碼。"""
        self._update_url_status("Localtunnel", "starting", priority=3)
        if not self._ensure_localtunnel_installed(): self._update_url_status("Localtunnel", "error", error="安裝失敗"); return
        proc = subprocess.Popen(["npx", "localtunnel", "--port", str(self._port)], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8')
        self._processes.append(proc)
        url_pattern = re.compile(r"your url is: (https://[a-zA-Z0-9-]+\.loca\.lt)")
        for line in iter(proc.stdout.readline, ''):
            if self._stop_event.is_set(): break
            self._log("DEBUG", line.strip(), "Localtunnel")
            if match := url_pattern.search(line):
                tunnel_url = match.group(1)
                self._log("INFO", f"✅ Localtunnel URL '{tunnel_url}' 已獲取，正在查詢通道密碼...", "Localtunnel")
                password = "查詢中..."
                try:
                    # 自動訪問 loca.lt/mytunnelpassword 來獲取當前 IP 的通道密碼。
                    result = subprocess.run(["curl", "https://loca.lt/mytunnelpassword"], capture_output=True, text=True, timeout=10, check=True)
                    password = result.stdout.strip()
                    self._log("SUCCESS", f"✅ 已成功獲取 Localtunnel 密碼。", "Localtunnel")
                except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError) as e:
                    self._log("WARN", f"查詢 Localtunnel 密碼失敗: {e}", "Localtunnel"); password = "查詢失敗"
                except Exception as e:
                    self._log("ERROR", f"查詢 Localtunnel 密碼時發生未知錯誤: {e}", "Localtunnel"); password = "未知錯誤"
                self._update_url_status("Localtunnel", "ready", url=tunnel_url, password=password, priority=3)
                return
        if not self._stop_event.is_set(): self._update_url_status("Localtunnel", "error", error="無法從日誌中解析 URL")

    def _run_colab_proxy(self):
        """啟動 Colab 內建的代理服務。"""
        self._update_url_status("Colab", "starting", priority=1)
        for attempt in range(10): # 增加重試機制，因為 Colab 代理有時需要時間初始化。
            if self._stop_event.is_set(): return
            try:
                url = colab_output.eval_js(f'google.colab.kernel.proxyPort({self._port})', timeout_sec=10)
                if url and url.strip(): self._update_url_status("Colab", "ready", url=url, priority=1); return
                self._log("WARN", f"Colab 代理嘗試 #{attempt+1} 返回空 URL。", "Colab")
            except Exception as e: self._log("WARN", f"Colab 代理嘗試 #{attempt+1} 失敗: {e}", "Colab")
            time.sleep(2)
        self._update_url_status("Colab", "error", error="重試 10 次後失敗")

    def stop(self):
        """停止所有通道進程。"""
        self._stop_event.set()
        for p in self._processes:
            if p.poll() is None:
                try: p.terminate()
                except ProcessLookupError: pass
        for t in self._threads: t.join(timeout=2)

# ==============================================================================
# SECTION 2: 核心功能函式
# ==============================================================================
def create_log_viewer_html(log_manager, display_manager):
    """ 產生最終的 HTML 日誌報告，包含複製按鈕和可摺疊的日誌區域。"""
    try:
        full_log_history = [f"[{log['timestamp'].isoformat()}] [{log['level']}] {log['message']}" for log in log_manager.get_full_history()]
        screen_output = "\n".join(display_manager._build_output_buffer())
        log_to_display = "\n".join(full_log_history[-LOG_COPY_MAX_LINES:])
        escaped_log_for_textarea = html.escape(log_to_display)
        escaped_screen_for_textarea = html.escape(screen_output)
        screen_id = f"screen-area-{int(time.time() * 1000)}"
        log_id = f"log-area-{int(time.time() * 1000)}"

        # 使用 textarea 方案來儲存日誌內容，這是最穩定可靠的複製到剪貼簿的方法。
        return f'''
            <style>
                .collapsible-log {{ margin-top: 15px; margin-bottom: 15px; border: 1px solid #e0e0e0; padding: 12px; border-radius: 8px; background-color: #fafafa; }}
                .collapsible-log summary {{ cursor: pointer; font-weight: bold; color: #333; }}
                .collapsible-log pre {{ background-color: #fff; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 13px; color: #444; max-height: 400px; overflow-y: auto; }}
                .copy-button {{ padding: 8px 16px; margin: 5px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; background-color: #f0f0f0; font-family: sans-serif; }}
                .copy-button:hover {{ background-color: #e0e0e0; }}
            </style>
            <script>
                function copyFromTextarea(elementId, button) {{
                    const ta = document.getElementById(elementId);
                    if (!ta) {{ console.error("Textarea not found:", elementId); return; }}
                    navigator.clipboard.writeText(ta.value).then(() => {{
                        const originalText = button.innerText;
                        button.innerText = "✅ 已複製!";
                        setTimeout(() => {{ button.innerText = originalText; }}, 2000);
                    }}, (err) => {{
                        button.innerText = "❌ 複製失敗";
                        console.error('複製失敗: ', err);
                    }});
                }}
            </script>

            <textarea id="{screen_id}" style="position:absolute; left: -9999px; top: -9999px;" readonly>{escaped_screen_for_textarea}</textarea>
            <textarea id="{log_id}" style="position:absolute; left: -9999px; top: -9999px;" readonly>{escaped_log_for_textarea}</textarea>

            <div>
                <button class="copy-button" onclick="copyFromTextarea('{screen_id}', this)">📋 複製上方最終畫面</button>
            </div>
            <details class="collapsible-log">
                <summary>點此展開/收合最近 {len(full_log_history[-LOG_COPY_MAX_LINES:])} 條詳細日誌</summary>
                <div style="margin-top: 12px;">
                    <button class="copy-button" onclick="copyFromTextarea('{log_id}', this)">📄 複製下方完整日誌</button>
                    <pre><code>{escaped_log_for_textarea}</code></pre>
                    <button class="copy-button" onclick="copyFromTextarea('{log_id}', this)">📄 複製下方完整日誌</button>
                </div>
            </details>
        '''
    except Exception as e:
        return f"<p>❌ 產生最終日誌報告時發生錯誤: {html.escape(str(e))}</p>"

def archive_reports(log_manager, start_time, end_time, status):
    """將本次執行的日誌和效能報告儲存到檔案中。"""
    print("\n\n" + "="*60 + "\n--- 任務結束，開始執行自動歸檔 ---\n" + "="*60)
    try:
        root_folder = Path(LOG_ARCHIVE_ROOT_FOLDER)
        root_folder.mkdir(exist_ok=True)
        ts_folder_name = start_time.strftime('%Y-%m-%dT%H-%M-%S%z')
        report_dir = root_folder / ts_folder_name
        report_dir.mkdir(exist_ok=True)
        log_history = log_manager.get_full_history()
        detailed_log_content = f"# 詳細日誌\n\n```\n" + "\n".join([f"[{log['timestamp'].isoformat()}] [{log['level']}] {log['message']}" for log in log_history]) + "\n```"
        (report_dir / "詳細日誌.md").write_text(detailed_log_content, encoding='utf-8')
        duration = end_time - start_time
        perf_report_content = f"# 效能報告\n\n- **任務狀態**: {status}\n- **開始時間**: `{start_time.isoformat()}`\n- **結束時間**: `{end_time.isoformat()}`\n- **總耗時**: `{str(duration)}`\n"
        (report_dir / "效能報告.md").write_text(perf_report_content.strip(), encoding='utf-8')
        (report_dir / "綜合報告.md").write_text(f"# 綜合報告\n\n{perf_report_content}\n{detailed_log_content}", encoding='utf-8')
        print(f"✅ 報告已成功歸檔至: {report_dir}")
    except Exception as e: print(f"❌ 歸檔報告時發生錯誤: {e}")

# ==============================================================================
# SECTION 2.5: 安裝系統級依賴 (FFmpeg)
# ==============================================================================
# 某些功能可能需要 FFmpeg，在此處提前安裝。
print("檢查並安裝系統級依賴 FFmpeg...")
try:
    if subprocess.run(["which", "ffmpeg"], capture_output=True).returncode != 0:
        print("未偵測到 FFmpeg，開始安裝...")
        # 使用 -qq 參數來減少安裝過程中的輸出，保持儀表板乾淨。
        subprocess.run(["apt-get", "update", "-qq"], check=True)
        subprocess.run(["apt-get", "install", "-y", "-qq", "ffmpeg"], check=True)
        print("✅ FFmpeg 安裝完成。")
    else:
        print("✅ FFmpeg 已安裝。")
except Exception as e:
    print(f"❌ 安裝 FFmpeg 時發生錯誤: {e}")

# ==============================================================================
# SECTION 3: 主程式執行入口
# ==============================================================================
def main():
    """主函數，協調所有管理器和流程。"""
    start_time_monotonic = time.monotonic()
    # 建立一個共享的字典，用於跨執行緒和管理器傳遞狀態。
    shared_stats = {"start_time_monotonic": start_time_monotonic, "status": "初始化...", "urls": {}}
    log_manager, display_manager, server_manager, tunnel_manager = None, None, None, None
    start_time = datetime.now(pytz.timezone(TIMEZONE))
    try:
        # 初始化所有管理器
        log_levels = {name: globals()[name] for name in globals() if name.startswith("SHOW_LOG_LEVEL_")}
        log_manager = LogManager(max_lines=LOG_DISPLAY_LINES, timezone_str=TIMEZONE, log_levels_to_show=log_levels)
        server_manager = ServerManager(log_manager=log_manager, stats_dict=shared_stats)
        display_manager = DisplayManager(log_manager=log_manager, stats_dict=shared_stats, refresh_rate=UI_REFRESH_SECONDS)

        # 啟動儀表板和伺服器管理器
        display_manager.start()
        server_manager.start()

        # 等待伺服器就緒，設有超時機制
        log_manager.log("INFO", f"設定伺服器啟動超時時間為 {SERVER_READY_TIMEOUT} 秒...")
        if server_manager.server_ready_event.wait(timeout=SERVER_READY_TIMEOUT):
            if not server_manager.port:
                log_manager.log("CRITICAL", "伺服器已就緒，但未能解析出 API 埠號。無法建立代理連結。")
            else:
                # 伺服器就緒後，才啟動通道管理器
                log_manager.log("SUCCESS", f"✅ 後端服務已在埠號 {server_manager.port} 上就緒，正在啟動所有代理通道...")
                tunnel_manager = TunnelManager(log_manager=log_manager, stats_dict=shared_stats, port=server_manager.port)
                tunnel_manager.start()
        else:
            # 如果超時，則記錄嚴重錯誤並退出。
            shared_stats['status'] = f"❌ 伺服器啟動超時 ({SERVER_READY_TIMEOUT}秒)"
            log_manager.log("CRITICAL", f"伺服器在 {SERVER_READY_TIMEOUT} 秒內未能就緒。啟動失敗。")
            raise SystemExit(f"Server did not start within {SERVER_READY_TIMEOUT} seconds.")

        # 等待伺服器執行緒結束（通常是因為使用者手動停止或發生錯誤）
        while server_manager._thread.is_alive(): time.sleep(1)

    except (KeyboardInterrupt, SystemExit) as e:
        # 處理使用者手動中斷 (Ctrl+C) 或系統退出。
        if isinstance(e, SystemExit):
            if log_manager: log_manager.log("CRITICAL", f"系統因致命錯誤退出: {e}")
        else: # KeyboardInterrupt
            if log_manager: log_manager.log("WARN", "🛑 偵測到使用者手動中斷...")
    except Exception as e:
        if log_manager: log_manager.log("CRITICAL", f"❌ 發生未預期的致命錯誤: {e}")
        else: print(f"❌ 發生未預期的致命錯誤: {e}")
    finally:
        # 清理程序：無論成功或失敗，都確保所有背景執行緒和子進程都被安全關閉。
        if display_manager and display_manager._thread.is_alive(): display_manager.stop()
        if 'tunnel_manager' in locals() and tunnel_manager: tunnel_manager.stop()
        if server_manager: server_manager.stop()
        end_time = datetime.now(pytz.timezone(TIMEZONE))

        # 在最後顯示最終的報告和日誌。
        if log_manager and display_manager:
            clear_output(); print("\n".join(display_manager._build_output_buffer()))
            print("\n--- ✅ 所有任務完成，系統已安全關閉 ---")
            display(HTML(create_log_viewer_html(log_manager, display_manager)))
            archive_reports(log_manager, start_time, end_time, shared_stats.get('status', '未知'))

if __name__ == "__main__":
    main()
